<!doctype html>
<html lang="cs">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="manifest" href="./manifest.webmanifest">
<meta name="apple-mobile-web-app-title" content="Bernio">
<title>Bernio</title>
<style>
  :root{
    --case:#203347; --lcd:#e9f0da; --lcd-text:#112016;
    --num:#d2d6dd; --num-text:#17202a;
    --fn:#2a3b4f;  --fn-text:#f7fbff;
    --pink:#f0a9ba; --pink2:#f4c5d0; --oval:#e8edf3; --shift:#ffd447; --alpha:#ff6b6b;
    --gap:10px; --r:18px; --shadow:0 2px 0 rgba(0,0,0,.35);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;overflow:hidden}
  body{
    background:#0f1722;display:grid;place-items:center;
    padding:env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    color:#fff; overscroll-behavior:contain;
  }
  .menu-top{ font-size: clamp(18px,4.2vw,22px); letter-spacing:.04em }
  .menu-bot{ font-size: clamp(16px,3.8vw,20px); font-weight:700 }
  .menu-grid{ display:flex; justify-content:space-between; padding:0 6px }
  .menu-grid span{ min-width: 30%; text-align:center }
/* MODE – horní řádek: tři nápisy vlevo/na střed/vpravo, bez změny výšky */
/* Horní MODE řádek – přesná L|C|R mřížka, velké jako zadávací text */
/* Horní MODE řádek – Deg | Rad | Gra (nebo ExS | ExE | Tea) vlevo/střed/vpravo */
.modebar{
  display:grid;
  grid-template-columns:1fr 1fr 1fr;
  align-items:center;
  width:100%;
  margin:0; padding:0;
}
.modebar .label{
  font-size:clamp(24px,6.2vw,33px); /* stejná jako zadávání */
  line-height:1.15;
  margin:0; padding:0;
}
.modebar .label:nth-child(1){ justify-self:start; }
.modebar .label:nth-child(2){ justify-self:center; }
.modebar .label:nth-child(3){ justify-self:end; }

/* Spodní MODE řádek – 1 | 2 | 3 vlevo/střed/vpravo; velikost jako výsledky (.res) */
.numrow{
  display:grid;
  grid-template-columns:1fr 1fr 1fr;
  align-items:center;
  width:100%;
  margin:0; padding:0;
  text-align:initial;     /* zruší pravé zarovnání .res pro tento obsah */
  font-size:inherit;      /* zdědí clamp z .res → stejná velikost jako výsledky */
}
.numrow span:nth-child(1){ justify-self:start; }
.numrow span:nth-child(2){ justify-self:center; }
.numrow span:nth-child(3){ justify-self:end; }
/* === MODE speciální layout pro spodní řádek s čísly === */
.res.mode{
  display:block;       /* v MODE nechceme flex-justify vpravo */
  text-align:initial;
  margin-left:0;
  min-width:100%;
  height:1.34em;       /* stejná FIXNÍ výška jako běžný výsledek */
  overflow:hidden;
}

.res.mode .numrow{
  display:grid;
  grid-template-columns: 1fr 1fr 1fr;
  align-items:center;
  width:100%;
  height:100%;         /* vyplň celý řádek */
}

.res.mode .numrow span:nth-child(1){ justify-self:start; }
.res.mode .numrow span:nth-child(2){ justify-self:center; }
.res.mode .numrow span:nth-child(3){ justify-self:end; }

  .calc{
    width:min(480px,100vw);
    height:auto;
    background:linear-gradient(#203347,#1a2c3d);
    border-radius:28px; padding:18px 14px 20px;
    box-shadow:0 24px 50px rgba(0,0,0,.55), inset 0 6px 0 rgba(255,255,255,.06);
    display:grid; grid-template-rows:auto auto; gap:12px;
    transform-origin: top center;
  }
.display{
  background:var(--lcd); color:var(--lcd-text); border-radius:10px;
  padding:12px 14px; box-shadow:inset 0 3px 4px rgba(0,0,0,.25);
  font-family:ui-monospace,Menlo,Consolas,monospace;
  display:grid; grid-template-rows:auto auto; gap:0px; /* menší mezera */
  position:relative;
}
#exprWrap{
  font-size:clamp(26px,7vw,36px);  /* o kousek větší než dřív */
  line-height:1.28;
  min-height:1.46em;
  white-space:nowrap;
  overflow:hidden;
  position:relative;
}

  #expr{display:block; width:100%; white-space:nowrap; padding-right:8px;}

  .line2{display:flex; align-items:center; gap:8px; min-height:1.34em}

  .badges{
    position:absolute; top:4px; left:8px; right:8px;
    display:flex; gap:8px; flex-wrap:wrap; pointer-events:none;
  }
  .badge{
    background:transparent; border:none; color:#1b2b3b;
    border-radius:0; padding:0; font-size:.8em; line-height:1; user-select:none;
  }
  .badge.auto{display:none}
  .badge.auto.on{display:inline-flex}
  .badge.always{display:inline-flex}

.res{
  display:flex;                   /* aby sup/exp nevytahoval řádek */
  align-items:center;
  justify-content:flex-end;       /* výsledek vpravo (mimo MODE) */
  margin-left:auto;
  font-size:clamp(26px,7.2vw,36px);
  line-height:1.2;
  font-weight:700;
  min-width:40%;
  height:1.34em;                  /* FIXNÍ výška řádku výsledku */
  overflow:hidden;                /* nic nevyleze ven */
}



  .res .sci .times, .res .sci .ten{ font-size:.8em; }
  .res .sci sup.exp{ font-size:.5em; vertical-align:super; }

  .boards{display:grid;grid-template-rows:auto auto;gap:12px}
  .topgrid{display:grid;grid-template-columns:repeat(6,1fr);gap:var(--gap);grid-auto-rows:minmax(46px,auto);} 
  .botgrid{display:grid;grid-template-columns:repeat(5,1fr);gap:var(--gap);grid-auto-rows:minmax(64px,auto);} 

  .oval{background:var(--oval);color:#263445;border-radius:18px;padding:.6em .2em;text-align:center;font-weight:700;box-shadow:var(--shadow);touch-action:manipulation;-webkit-tap-highlight-color:transparent;cursor:pointer}
  #btnSHIFT{color:#b08c00} #btnALPHA{color:var(--alpha)} #btnFS{font-weight:800}
  .replay{background:#bfcbd9;color:#3b4b5c;border-radius:999px;font-size:20px}
  .span2{grid-row:span 2}

  .key{position:relative;border:none;border-radius:var(--r);padding:1.05em .3em .8em;text-align:center;box-shadow:var(--shadow);font-size:clamp(15px,3.2vw,19px);user-select:none;touch-action:manipulation;-webkit-tap-highlight-color:transparent;cursor:pointer}
  .key:active{transform:translateY(1px)}
  .num{background:var(--num);color:var(--num-text)} .fn{background:var(--fn);color:var(--fn-text)}
  .pink{background:var(--pink);color:#3b1c26} .pink.soft{background:var(--pink2)}
  .legend{position:absolute;top:6px;left:8px;font-size:.72em;color:#b08c00;opacity:.9;pointer-events:none}
  .main{display:block}
  .botgrid .key{padding:.85em .25em .6em;font-size:clamp(22px,7.2vw,34px)}
  .root{position:relative;display:inline-block;padding-left:.05em}
  .root .rad{display:inline-block;padding-left:.2em;margin-left:.05em;border-top:2px solid currentColor;line-height:1}
  .root small{font-size:.7em;vertical-align:super;margin-right:.05em}
  .root.small .rad{border-top-width:1.6px}
  .caret{display:inline-block;width:.7ch;text-align:center;animation:blink 1s step-end infinite;font-weight:700}
  @keyframes blink{50%{opacity:0}} sup{font-size:.7em}
  /* === TEST MODE UI === */

/* barvy řídíme přes CSS proměnné, tween dělá JS */
body.exam-on .calc{
  background: linear-gradient(var(--exam-c1, #ffe8f2), var(--exam-c2, #ffdbe8));
  /* žádný CSS transition – plynulost zajišťuje JS */
}


/* Kód vpravo nahoře – stejná řádka a velikost jako ostatní badge */
#bExamCode{
  /* díky inline style margin-left:auto je už zarovnán vpravo */
  color:#b3125d;
  background:transparent; /* stejné jako ostatní .badge */
}
#bExamTimer{
  color:#0bb37b;         /* jiná barva než kód */
  font-weight:700;
}

</style>
</head>
<body>
<div class="calc" id="calc">
  <!-- DISPLEJ -->
  <div class="display">
    <div id="exprWrap"><div id="expr"></div></div>
    <div class="line2">
      <div class="badges">
        <span class="badge auto" id="bShift">SHIFT</span>
        <span class="badge auto" id="bHyp">HYP</span>
        <span class="badge always" id="bDRG">DEG</span>
        <span class="badge auto" id="bDMS">DMS</span>
        <span class="badge auto" id="bENG">ENG</span>
        <span class="badge auto" id="bMem">M</span>
        <span class="badge auto" id="bExamTimer"></span>
        <span class="badge auto" id="bExamCode" style="margin-left:auto"></span>
      </div>
      <span class="res" id="res"></span>
    </div>
  </div>

  <!-- HORNÍ 6×5 -->
  <div class="boards">
    <div class="topgrid">
      <button class="oval" id="btnSHIFT">SHIFT</button>
      <button class="oval" id="btnQR">QR</button>
      <button class="oval replay span2" id="btnLeft">◀</button>
      <button class="oval replay span2" id="btnRight">▶</button>
      <button class="oval" id="btnMODE"><span class="main">MODE</span></button>
      <button class="oval" id="btnFS">⛶</button>

      <button class="key fn" id="btnInv"><span class="legend">x!</span><span class="main">x⁻¹</span></button>
      <button class="key fn" id="btnComb"><span class="legend">nPr</span><span class="main">nCr</span></button>
      <button class="key fn" id="btnPolRec"><span class="legend">Rec(</span><span class="main">Pol(</span></button>
      <button class="key fn" id="btnPow3"><span class="legend"><span class="root small"><small>3</small>√<span class="rad">x</span></span></span><span class="main">x³</span></button>

      <button class="key fn" id="btnFracKey"><span class="legend">d/c</span><span class="main">a b/c</span></button>
      <button class="key fn" id="btnSqrt"><span class="main"><span class="root">√<span class="rad">x</span></span></span></button>
      <button class="key fn" id="btnPow2"><span class="main">x²</span></button>
      <button class="key fn" id="btnPow"><span class="legend"><span class="root small"><small>y</small>√<span class="rad">x</span></span></span><span class="main">^</span></button>
      <button class="key fn" data-fn="log"><span class="legend">10ˣ</span><span class="main">log</span></button>
      <button class="key fn" data-fn="ln"><span class="legend">eˣ</span><span class="main">ln</span></button>

      <button class="key fn" id="btnNeg"><span class="main">(−)</span></button>
      <button class="key fn" id="btnDMSsym"><span class="main">° ′ ″</span></button>
      <button class="key fn" id="btnHYP"><span class="main">hyp</span></button>
      <button class="key fn" data-trig="sin"><span class="legend">sin⁻¹</span><span class="main">sin</span></button>
      <button class="key fn" data-trig="cos"><span class="legend">cos⁻¹</span><span class="main">cos</span></button>
      <button class="key fn" data-trig="tan"><span class="legend">tan⁻¹</span><span class="main">tan</span></button>

      <button class="key fn" id="btnRCLSTO"><span class="legend">STO</span><span class="main">RCL</span></button>
      <button class="key fn" id="btnENG"><span class="main">ENG</span></button>
      <button class="key fn" data-ins="(" id="btnParL"><span class="main">(</span></button>
      <button class="key fn" data-ins=")" id="btnParR"><span class="main">)</span></button>
      <button class="key fn" data-ins="," id="btnComma"><span class="main">,</span></button>
      <button class="key fn" id="btnMpm"><span class="legend">M−</span><span class="main">M+</span></button>
    </div>

    <!-- DOLNÍ 5×4 -->
    <div class="botgrid">
      <button class="key num" data-ins="7"><span class="main">7</span></button>
      <button class="key num" data-ins="8"><span class="main">8</span></button>
      <button class="key num" data-ins="9"><span class="main">9</span></button>
      <button class="key pink" data-act="del"><span class="legend">INS</span><span class="main">DEL</span></button>
      <button class="key pink soft" data-act="ac"><span class="main">AC</span></button>

      <button class="key num" data-ins="4"><span class="main">4</span></button>
      <button class="key num" data-ins="5"><span class="main">5</span></button>
      <button class="key num" data-ins="6"><span class="main">6</span></button>
      <button class="key num" data-ins="×"><span class="main">×</span></button>
      <button class="key num" data-ins="÷"><span class="main">÷</span></button>

      <button class="key num" data-ins="1"><span class="main">1</span></button>
      <button class="key num" data-ins="2"><span class="main">2</span></button>
      <button class="key num" data-ins="3"><span class="main">3</span></button>
      <button class="key num" data-ins="+"><span class="main">+</span></button>
      <button class="key num" data-ins="−"><span class="main">−</span></button>

      <button class="key num" id="btn0"><span class="legend">Rnd</span><span class="main">0</span></button>
      <button class="key num" id="btnDot"><span class="legend">Ran#</span><span class="main">.</span></button>
      <button class="key num" id="btnEXP"><span class="legend">π</span><span class="main">EXP</span></button>
      <button class="key num" id="btnAns"><span class="legend">DRG▶</span><span class="main">Ans</span></button>
      <button class="key num" id="btnEq"><span class="legend">%</span><span class="main">=</span></button>
    </div>
  </div>
</div>

<!-- RESET SW/Cache helper -->
<script>
(async () => {
  const p = new URL(location.href).searchParams;
  if (p.get('reset') === '1' && 'serviceWorker' in navigator) {
    try {
      const regs = await navigator.serviceWorker.getRegistrations();
      for (const r of regs) await r.unregister();
      if ('caches' in window) {
        const keys = await caches.keys();
        for (const k of keys) await caches.delete(k);
      }
    } catch {}
    location.replace(location.pathname);
  }
})();
</script>
<script>
// ---- Audio helper (odemknutí a jedno pípnutí) ----
const Sound = (() => {
  let ctx = null, unlocked = false;

  function ensureCtx() {
    if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
    return ctx;
  }
  async function unlock() {
    try {
      ensureCtx();
      if (ctx.state === 'suspended') await ctx.resume();
      // krátký tichý blip, aby si prohlížeč zapsal "interakci"
      const o = ctx.createOscillator(), g = ctx.createGain();
      g.gain.value = 0.00001; o.connect(g).connect(ctx.destination);
      o.start(); o.stop(ctx.currentTime + 0.01);
      unlocked = true;
    } catch {}
  }
  function installGlobalUnlockers() {
    const once = () => { unlock(); window.removeEventListener('pointerdown', once); window.removeEventListener('keydown', once); };
    window.addEventListener('pointerdown', once, { passive:true });
    window.addEventListener('keydown', once);
  }
  function isUnlocked(){ return unlocked && ctx && ctx.state === 'running'; }

  async function beep(ms=180, hz=880) {
    try {
      ensureCtx();
      if (ctx.state === 'suspended') await ctx.resume();
      const o = ctx.createOscillator(), g = ctx.createGain();
      o.type = 'square'; o.frequency.value = hz; g.gain.value = 0.06;
      o.connect(g).connect(ctx.destination); o.start();
      setTimeout(() => { try{o.stop();}catch{} }, ms);
    } catch {}
  }
  installGlobalUnlockers();
  return { unlock, beep, isUnlocked };
})();

// ---- iOS povolení pro oba senzory (motion + orientation) ----
const SensorPermissions = {
  async requestAll() {
    // iOS 13+ potřebuje výslovné povolení; na Androidu to jen proběhne
    try {
      if (typeof DeviceMotionEvent !== 'undefined' &&
          typeof DeviceMotionEvent.requestPermission === 'function') {
        const p = await DeviceMotionEvent.requestPermission();
        if (p !== 'granted') throw new Error('Motion denied');
      }
    } catch {}
    try {
      if (typeof DeviceOrientationEvent !== 'undefined' &&
          typeof DeviceOrientationEvent.requestPermission === 'function') {
        const p = await DeviceOrientationEvent.requestPermission();
        if (p !== 'granted') throw new Error('Orientation denied');
      }
    } catch {}
  }
};
</script>
<script>
// === Wake Lock + iOS hidden-video helpery (globální) ===
let wakeLock = null;
let hiddenVideoEl = null;

async function enableWakeLock() {
  try {
    if ('wakeLock' in navigator) {
      wakeLock = await navigator.wakeLock.request('screen');
      wakeLock.addEventListener('release', () => {
        console.log('Wake Lock uvolněn');
      });
    }
  } catch (err) {
    console.warn('Nepodařilo se zapnout Wake Lock:', err);
  }
}

async function disableWakeLock() {
  try {
    if (wakeLock) {
      await wakeLock.release();
      wakeLock = null;
    }
  } catch (err) {
    console.warn('Chyba při vypínání Wake Locku:', err);
  }
}

// iOS: neviditelné video, aby se displej nevypínal
function startHiddenVideoTrick() {
  if (hiddenVideoEl) return; // už běží

  hiddenVideoEl = document.createElement('video');
  hiddenVideoEl.src = "data:video/mp4;base64,AAAA"; // prázdný zdroj
  hiddenVideoEl.muted = true;
  hiddenVideoEl.loop = true;
  hiddenVideoEl.playsInline = true;
  hiddenVideoEl.style.position = 'absolute';
  hiddenVideoEl.style.width = '1px';
  hiddenVideoEl.style.height = '1px';
  hiddenVideoEl.style.opacity = '0';
  hiddenVideoEl.style.pointerEvents = 'none';
  document.body.appendChild(hiddenVideoEl);

  // iOS vyžaduje user-gesture → po prvním tapu spustíme play()
  const playAttempt = () => {
    hiddenVideoEl.play().catch(() => {});
    document.removeEventListener('pointerdown', playAttempt);
    document.removeEventListener('touchstart', playAttempt);
  };
  document.addEventListener('pointerdown', playAttempt, { passive: true });
  document.addEventListener('touchstart', playAttempt, { passive: true });
}

function stopHiddenVideoTrick() {
  if (hiddenVideoEl) {
    try { hiddenVideoEl.pause(); } catch {}
    hiddenVideoEl.remove();
    hiddenVideoEl = null;
  }
}
</script>

<script>
/* ===== drobné utily ===== */
const qs=s=>document.querySelector(s);
function onPD(el, fn){ if(!el) return; el.addEventListener('pointerdown', fn, {passive:true}); }
function onPDAll(sel,fn){ document.querySelectorAll(sel).forEach(el=>onPD(el,()=>fn(el))); }
/* === autopřizpůsobení výšce v ne-fullscreenu === */
const calcBox = document.getElementById('calc');
function isFS(){ const d=document; return !!(d.fullscreenElement||d.webkitFullscreenElement); }

function fitToViewport(){
  if(isFS()){
    calcBox.style.transform='scale(1)';
    calcBox.style.marginTop='';
    return;
  }
  const vv = window.visualViewport ? window.visualViewport.height : window.innerHeight;
  const cs = getComputedStyle(document.body);
  const avail = vv - parseFloat(cs.paddingTop||0) - parseFloat(cs.paddingBottom||0);

  calcBox.style.transform='scale(1)';
  calcBox.style.marginTop='';
  const need = calcBox.getBoundingClientRect().height;

  const s = Math.min(1, avail / need);
  if(s < 1){
    calcBox.style.transform = `scale(${s})`;
    const extra = (avail - need*s)/2;
    calcBox.style.marginTop = `${Math.max(0, extra)}px`;
  }
}
window.addEventListener('resize', fitToViewport);
window.addEventListener('orientationchange', fitToViewport);

/* ===== stav ===== */
const exprEl=qs('#expr'), resEl=qs('#res');
const bShift=qs('#bShift'), bHyp=qs('#bHyp'), bDRG=qs('#bDRG'), bENG=qs('#bENG'), bDMS=qs('#bDMS'), bMem=qs('#bMem');
const calcEl = document.getElementById('calc');
const TEACHER_URL = "https://berniocal.github.io/teacher.html"; // jediný zdroj pravdy

function renderModeMenu(){
  // MODE 1: Deg/Rad/Gra
  if (state.modeStage === 1) {
    exprEl.innerHTML =
      '<div class="modebar">' +
        '<span class="label">Deg</span>' +
        '<span class="label">Rad</span>' +
        '<span class="label">Gra</span>' +
      '</div>';
    resEl.classList.add('mode');   // ← zapni speciální layout pro čísla
    resEl.innerHTML = '<div class="numrow"><span>1</span><span>2</span><span>3</span></div>';
    return true;
  }
  // MODE 2: ExS/ExE/Tea
  if (state.modeStage === 2) {
    exprEl.innerHTML =
      '<div class="modebar">' +
        '<span class="label">ExS</span>' +
        '<span class="label">ExE</span>' +
        '<span class="label">Tea</span>' +
      '</div>';
    resEl.classList.add('mode');   // ← zapni speciální layout pro čísla
    resEl.innerHTML = '<div class="numrow"><span>1</span><span>2</span><span>3</span></div>';
    return true;
  }

  // Mimo MODE – vrať běžné chování (vpravo zarovnaný výsledek)
  resEl.classList.remove('mode');  // ← vypni speciální layout
  return false;
}

// akce menu čísel 1/2/3
function handleMenuChoice(digit){
  if(state.modeStage===1){
    if(digit==='1') state.drg='DEG';
    else if(digit==='2') state.drg='RAD';
    else if(digit==='3') state.drg='GRAD';
    state.modeStage=0; state.resultShown=false; state.resultStr='';
    render();
    return true;
  }
  if(state.modeStage===2){
    if(digit==='1'){ startExamScan(); }
    else if(digit==='2'){ endExamScan(); }
    else if(digit==='3'){ openTeacher(); }
    state.modeStage=0; render();
    return true;
  }
  return false;
}


  /* ========= ExamGuard: offline + pozadí + pohyb + LOCK ========= */

  const ExamGuard = (() => {
  const ui = {
    overlay: null,
    text: null
  };
const S = {
  active: false,
  locked: false,
  calibrating: false,
  grace: 0,
  lastMoveAt: 0,
  stillStart: 0,
  code: '',
  netTimer: 0,
  startAt:0, 
  uptimeTimer:0
};
  // ⬇️ sem vlož
  function refreshExamTimer(){
    const el = document.getElementById('bExamTimer');
    if (!el) return;
    const mins = Math.floor((Date.now() - S.startAt) / 60000);
    el.textContent = `${mins} min`;
  }


  // UI overlay
  function ensureUI(){
    if(ui.overlay) return;
    const ov = document.createElement('div');
    ov.style.cssText = "position:fixed;inset:0;background:rgba(0,0,0,.7);display:none;place-items:center;z-index:99999;color:#fff;font:700 22px/1.4 system-ui,Segoe UI,Roboto;text-align:center;padding:24px";
    const box = document.createElement('div');
    box.style.cssText = "max-width:520px;background:#2b0000;border:2px solid #ff3b30;border-radius:14px;padding:18px;box-shadow:0 10px 30px rgba(0,0,0,.5)";
    const h = document.createElement('div');
    h.textContent = "PODVOD – jdi k učiteli";
    h.style.cssText = "color:#ff3b30;font-size:24px;margin-bottom:8px";
    const t = document.createElement('div');
    t.id = "examGuardText";
    t.innerHTML = "Aplikace byla zablokována.";
    t.style.cssText = "opacity:.95";
    box.appendChild(h); box.appendChild(t); ov.appendChild(box);
    document.body.appendChild(ov);
    ui.overlay = ov; ui.text = t;
  }
  function showLock(msg){
    ensureUI();
    ui.text.innerHTML = msg || "Porušení pravidel.";
    ui.overlay.style.display = "grid";
  }

function alertBuzzer(){
  // krátká vibrace
  try{ navigator.vibrate && navigator.vibrate(250); }catch{}
  // jedno krátké pípnutí (~200 ms)
  try{
    const actx = new (window.AudioContext||window.webkitAudioContext)();
    const o = actx.createOscillator(); const g = actx.createGain();
    o.type = 'square'; o.frequency.value = 880; g.gain.value = 0.06;
    o.connect(g).connect(actx.destination); o.start();
    setTimeout(()=>{ o.stop(); actx.close(); }, 200);
  }catch{}
}


  function lock(reason){
    if(S.locked) return;
    S.locked = true; S.active = false; S.calibrating = false;
    detachSensors();
    if (S.netTimer) { clearInterval(S.netTimer); S.netTimer = 0; }
   if (S.uptimeTimer) { clearInterval(S.uptimeTimer); S.uptimeTimer = 0; }
   S.startAt = 0;
   const tEl = document.getElementById('bExamTimer');
   if (tEl) { tEl.classList.remove('on'); tEl.textContent = ''; }

    showLock(reason || "Aplikace byla zablokována.");
    alertBuzzer();
  }

  function onVisibility(){
    if(!S.active) return;
    if(document.hidden && Date.now() > S.grace){ 
      lock("Aplikace šla do pozadí / byla skryta.");
    }
  }
function onOnline(){
  if(!S.active) return;
  if(navigator.onLine){
    // pípni a zamkni
    Sound.beep(200, 880);
    lock("Zařízení je online (wifi/data).");
  }
}

// === Motion + Orientation senzory (s fallbackem) ===
// === Motion + Orientation senzory (s fallbackem) ===
let motionHandler = null;
let orientHandler = null;
let motionSeenTimer = null;
let motionEverSeen = false;

function attachSensors(){
  document.addEventListener('visibilitychange', onVisibility);
  window.addEventListener('online', onOnline);

  // Primární: devicemotion (akcelerometr)
  motionHandler = (ev) => {
    if (!S.active) return;
    motionEverSeen = true;

    const a = ev.accelerationIncludingGravity || ev.acceleration || {};
    const ax = Math.abs(a.x || 0), ay = Math.abs(a.y || 0), az = Math.abs(a.z || 0);
    const mag = Math.sqrt(ax*ax + ay*ay + az*az); // ~ m/s^2, včetně gravitační složky

    const now = Date.now();

    // Kalibrace – čekáme, až se telefon položí a zůstane ~3 s v klidu
    if (S.calibrating) {
      const still = mag < 0.25; // trochu benevolentnější klid
      if (still) {
        if (!S.stillStart) S.stillStart = now;
        if (now - S.stillStart > 2800) {
          S.calibrating = false;
          S.grace = now + 1200; // krátká benevolence po kalibraci
        }
      } else {
        S.stillStart = 0;
      }
      return;
    }

    // Po grace okně detekujeme "zvednutí" – souvislý silnější pohyb
    if (now > S.grace) {
      if (mag > 2.0) {                 // práh zrychlení
        if (!S.lastMoveAt) S.lastMoveAt = now;
        if (now - S.lastMoveAt > 250) { // ~0.25 s v kuse
          Sound.beep(200, 880);
          lock("Detekován pohyb/zvednutí telefonu.");
        }
      } else {
        S.lastMoveAt = 0;
      }
    }
  };
  window.addEventListener('devicemotion', motionHandler, { passive:true });

  // Pokud nepřijde žádný devicemotion event, přepneme se na orientation fallback
  motionEverSeen = false;
  if (motionSeenTimer) clearTimeout(motionSeenTimer);
  motionSeenTimer = setTimeout(() => {
    if (!motionEverSeen) attachOrientationFallback();
  }, 1800);
}

function attachOrientationFallback(){
  // Fallback: deviceorientation (změny náklonu v °)
  let base = null;
  let lastExceedAt = 0;

  orientHandler = (ev) => {
    if (!S.active) return;
    const now = Date.now();

    const beta  = (typeof ev.beta  === 'number') ? ev.beta  : 0; // -180..180 (pitch)
    const gamma = (typeof ev.gamma === 'number') ? ev.gamma : 0; //  -90.. 90 (roll)

    if (S.calibrating) {
      if (!base) base = { beta, gamma };
      const dBeta  = beta  - base.beta;
      const dGamma = gamma - base.gamma;
      const delta  = Math.hypot(dBeta, dGamma);

      const still = delta < 2.5; // ~2.5°
      if (still) {
        if (!S.stillStart) S.stillStart = now;
        if (now - S.stillStart > 2800) {
          S.calibrating = false;
          S.grace = now + 1200;
        }
      } else {
        S.stillStart = 0;
        base = { beta, gamma };
      }
      return;
    }

    if (!base) base = { beta, gamma };
    const dBeta  = beta  - base.beta;
    const dGamma = gamma - base.gamma;
    const delta  = Math.hypot(dBeta, dGamma); // změna v °

    if (now > S.grace) {
      if (delta > 12) {                 // ~12° a víc
        if (!lastExceedAt) lastExceedAt = now;
        if (now - lastExceedAt > 240) { // > ~0.24 s v kuse
          Sound.beep(200, 880);
          lock("Detekován pohyb/zvednutí telefonu (orientační senzor).");
        }
      } else {
        lastExceedAt = 0;
      }
    }
  };

  window.addEventListener('deviceorientation', orientHandler, { passive:true });
}

function detachSensors(){
  document.removeEventListener('visibilitychange', onVisibility);
  window.removeEventListener('online', onOnline);

  if (motionHandler) {
    window.removeEventListener('devicemotion', motionHandler);
    motionHandler = null;
  }
  if (orientHandler) {
    window.removeEventListener('deviceorientation', orientHandler);
    orientHandler = null;
  }
  if (motionSeenTimer) {
    clearTimeout(motionSeenTimer);
    motionSeenTimer = null;
  }
  if (S.netTimer) { clearInterval(S.netTimer); S.netTimer = 0; }
}

// === PŘEPSAT: async function start(...) ===
// === PŘEPSAT: async function start(code) ===
async function start(code){
  if (S.active || S.locked) return;

  // Požadavek: být offline (režim letadlo)
  if (navigator.onLine) {
    ensureUI();
    ui.overlay.style.display = 'grid';
    ui.text.innerHTML = "Nejprve zapni <b>režim letadlo</b> (offline), pak to zkus znovu.";
    setTimeout(() => ui.overlay.style.display = 'none', 2800);
    return;
  }

  // Odemkni zvuk (aby šlo pípnout), vyžádej senzory (iOS)
  await Sound.unlock();
  if (!Sound.isUnlocked()) {
  ensureUI();
  ui.overlay.style.display = 'grid';
  ui.text.innerHTML = "Pro zvukové upozornění prosím <b>klepni na obrazovku</b> (povolí se audio).";
  setTimeout(() => ui.overlay.style.display = 'none', 2200);
}

  await SensorPermissions.requestAll();

  // Aktivace režimu a příprava senzorů
  S.active = true;
  S.locked = false;
  S.calibrating = true;
  S.code = String(code || '').toUpperCase().slice(0, 3);

  // TEST UI (růžové pozadí + badge s kódem vpravo nahoře)
  state.examActive = true;
  state.examCode = S.code;
  updateExamUI();
  startExamColorCycleDeterministic(S.code);
  enableWakeLock();          // udrží displej aktivní (Android/Chrome/PWA)
 startHiddenVideoTrick();   // iOS Safari workaround


  S.stillStart = 0;
  S.lastMoveAt = 0;
  S.grace = Date.now() + 1500; // krátká benevolence po položení
  attachSensors();
  S.startAt = Date.now();
refreshExamTimer(); // ať se hned ukáže 0 min

if (S.uptimeTimer) { clearInterval(S.uptimeTimer); S.uptimeTimer = 0; }
S.uptimeTimer = setInterval(() => {
  if (!S.active) return;
  refreshExamTimer();
}, 6000);

// periodický offline ping (1× spuštěný při startu)
if (S.netTimer) { clearInterval(S.netTimer); S.netTimer = 0; }
S.netTimer = setInterval(async () => {
  if (!S.active) return;
  try {
    await fetch('https://www.gstatic.com/generate_204', { mode:'no-cors', cache:'no-store' });
    Sound.beep(200, 880);
    lock("Zařízení je online (detekováno pingem).");
  } catch {}
}, 2000);

  // Info na displej
  state.resultShown = true;
  state.resultStr = " Polož telefon a nech ho 3 s v klidu…";
  render();
}



// === PŘEPSAT: function finish() ===
function finish(){
  if (!S.active && !S.locked) return;

  S.grace = Date.now() + 5000; // tolerance při ukončení
  detachSensors();
  S.active = false;
  S.code = '';
if (S.netTimer) { clearInterval(S.netTimer); S.netTimer = 0; }
// vypnout minutový časovač a schovat badge
 if (S.uptimeTimer) { clearInterval(S.uptimeTimer); S.uptimeTimer = 0; }
S.startAt = 0;
const tEl = document.getElementById('bExamTimer');
if (tEl) { tEl.classList.remove('on'); tEl.textContent = ''; }

  // Vypni TEST UI (vrátí pozadí a skryje badge s kódem)
  state.examActive = false;
  state.examCode = '';
  updateExamUI();
  stopExamColorCycle();
  disableWakeLock();
stopHiddenVideoTrick();


  state.resultShown = true;
  state.resultStr = "Zkouška ukončena.";
  render();
}

  return { start, finish, lock };
})();

// Hoist-safe definice (použitá v menu)
function openTeacher(){
  try{ window.open(TEACHER_URL, '_blank', 'noopener'); }catch(_){}
}
</script>

<script>
let state={ raw:'', cursor:0, ans:0, drg:'DEG', shift:false, hyp:false, eng:false,
            dmsDisplay:false, frac:false, fracMixed:true, memory:0, memOn:false,
            lastRes:null, resultShown:false, resultStr:'', editAfterResult:false,
            modeStage:0, repeat:null, examActive:false, examCode:'' };

/* ===== pretty + caret, auto scroll kurzoru ===== */
function prettySegments(raw){
  const segs=[]; let i=0; const push=(h,l)=>segs.push({html:h,len:l});
  while(i<raw.length){
    if(raw.startsWith('pow10(',i)){ push('10^(',6); i+=6; continue; }
    if(raw.startsWith('exp(',i)){   push('e^(',4);   i+=4; continue; }
    if(raw.startsWith('asin(',i)){  push('sin<sup>−1</sup>(',5); i+=5; continue; }
    if(raw.startsWith('acos(',i)){  push('cos<sup>−1</sup>(',5); i+=5; continue; }
    if(raw.startsWith('atan(',i)){  push('tan<sup>−1</sup>(',5); i+=5; continue; }
    if(raw.startsWith('sqrt(',i)){  push('√(',5); i+=5; continue; }
    if(raw.startsWith('cbrt(',i)){  push('∛(',5); i+=5; continue; }
    if(raw.startsWith('root(',i)){
      let j=i+5,y=''; while(j<raw.length&&/[0-9.]/.test(raw[j])) y+=raw[j++];
      if(raw[j]===','){ push(y+'√(', j-i+1); i=j+1; continue; }
    }
    if(raw[i]==='^' && raw[i+1]==='('){
      let j=i+2; while(j<raw.length && raw[j]!==')') j++;
      if(j<raw.length){ const expo=raw.slice(i+2,j).replace(/-/g,'−'); push('<sup>'+expo+'</sup>', j-i+1); i=j+1; continue; }
    }
    const ch=raw[i]; const pretty = ch==='*'?'×': ch==='/'?'÷': ch==='-'?'−': ch;
    push(pretty,1); i++;
  }
  return segs;
}
function scrollToCaret(){
  const wrap=document.getElementById('exprWrap');
  const c=wrap.querySelector('.caret');
  if(!c) return;
  const wr=wrap.getBoundingClientRect();
  const cr=c.getBoundingClientRect();
  const pad=8;
  if(cr.right>wr.right-pad) wrap.scrollLeft += (cr.right - wr.right + pad);
  else if(cr.left<wr.left+pad) wrap.scrollLeft -= (wr.left - cr.left + pad);
}
function render(){
  bShift.classList.toggle('on',state.shift);
  bHyp.classList.toggle('on',state.hyp);
  bENG.classList.toggle('on',state.eng);
  bDMS.classList.toggle('on',state.dmsDisplay);
  bMem.classList.toggle('on',state.memOn);
  bDRG.textContent=state.drg;
  calcEl.classList.toggle('shift-on', state.shift);

  if(renderModeMenu()){
    return;
  }
  const segs=prettySegments(state.raw);
  let out='', count=0, placed=false;
  for(const s of segs){
    if(!placed && state.cursor<=count){ out+='<span class="caret">_</span>'; placed=true; }
    out+=s.html; count+=s.len;
  }
  if(!placed) out+='<span class="caret">_</span>';
  exprEl.innerHTML = out;

  resEl.innerHTML = state.resultShown ? state.resultStr : '';

  scrollToCaret();
}
function updateExamUI(){
  document.body.classList.toggle('exam-on', !!state.examActive);

  const badgeCode = document.getElementById('bExamCode');
  const badgeTimer = document.getElementById('bExamTimer');

  // kód z QR
  if (badgeCode) {
    if (state.examActive && state.examCode){
      badgeCode.textContent = state.examCode.toUpperCase();
      badgeCode.classList.add('on');
    } else {
      badgeCode.textContent = '';
      badgeCode.classList.remove('on');
    }
  }

  // timer vlevo – jen v exam-mode
  if (badgeTimer) {
    if (state.examActive){
      badgeTimer.classList.add('on');
      // barva odlišená od kódu (klidně uprav podle vkusu)
      badgeTimer.style.color = '#0aa';
      badgeTimer.style.fontWeight = '700';
    } else {
      badgeTimer.textContent = '';
      badgeTimer.classList.remove('on');
    }
  }
}

  window.updateExamUI = updateExamUI;
// === Exam background tween (5 minut plynule) ===
let examRAF = 0;

function hashCode(str){
  let h = 0; for (let i=0;i<str.length;i++) h = (h*31 + str.charCodeAt(i)) >>> 0;
  return h >>> 0;
}
function seededRandom(seed){
  let x = (seed % 2147483647) || 1;
  return () => (x = (x * 48271) % 2147483647) / 2147483647;
}
function hsl(h, s, l){ return {h, s, l}; } // 0-360, 0-1, 0-1

function hslToRgbArray(h, s, l){
  // očekává h v [0..360), s,l v [0..1]; vrací [R,G,B] 0..255
  const c = (1 - Math.abs(2*l - 1)) * s;
  const hp = (h % 360) / 60;
  const x = c * (1 - Math.abs((hp % 2) - 1));
  let r=0,g=0,b=0;
  if (0<=hp&&hp<1){ r=c; g=x; b=0; }
  else if (1<=hp&&hp<2){ r=x; g=c; b=0; }
  else if (2<=hp&&hp<3){ r=0; g=c; b=x; }
  else if (3<=hp&&hp<4){ r=0; g=x; b=c; }
  else if (4<=hp&&hp<5){ r=x; g=0; b=c; }
  else { r=c; g=0; b=x; }
  const m = l - c/2;
  const R = Math.round((r+m)*255);
  const G = Math.round((g+m)*255);
  const B = Math.round((b+m)*255);
  return [R, G, B];
}
function rgbToCss(rgb){ const [R,G,B] = rgb; return `rgb(${R}, ${G}, ${B})`; }

function lerp(a, b, t){ return a + (b - a) * t; }
function lerpHsl(a, b, t){
  // plynule i přes 360/0 (zkrácenou cestou)
  let dh = ((b.h - a.h + 540) % 360) - 180;
  return hsl(
    (a.h + dh*t + 360) % 360,
    lerp(a.s, b.s, t),
    lerp(a.l, b.l, t)
  );
}

let tween = null;
/*
  tween = {
    rand,               // RNG pro deterministické další cíle
    start1, start2,     // HSL start gradientu
    end1, end2,         // HSL cíl gradientu
    t0,                 // start timestamp (ms)
    dur: 300000         // 5 minut
  }
*/
// === Forbidden / similar-to-base-color filter ===
const BASE_BG_HEX = ['#203347', '#1a2c3d']; // běžné pozadí kalkulačky

function hexToRgb(hex){
  const h = hex.replace('#','');
  return [parseInt(h.slice(0,2),16), parseInt(h.slice(2,4),16), parseInt(h.slice(4,6),16)];
}
function srgbToLinear(v){ // v ∈ [0..1]
  return (v <= 0.04045) ? (v/12.92) : Math.pow((v+0.055)/1.055, 2.4);
}
function rgbDistLinear(a, b){ // eukleid v lineárním RGB, citlivější na tmavé
  const al = a.map(v => srgbToLinear(v/255));
  const bl = b.map(v => srgbToLinear(v/255));
  const dx = al[0]-bl[0], dy = al[1]-bl[1], dz = al[2]-bl[2];
  return Math.sqrt(dx*dx + dy*dy + dz*dz);
}
const FORBIDDEN_RGB = BASE_BG_HEX.map(hexToRgb);
// práh podobnosti – 0.18 je docela přísný; zvětši → víc vyhazuje
const FORBIDDEN_DIST = 0.18;

function isNearForbidden(rgb){
  return FORBIDDEN_RGB.some(base => rgbDistLinear(rgb, base) < FORBIDDEN_DIST);
}

function randomPastel(rand){
  // původně sis bral h, s, l → nechávám styl podobný
  // Pastely: vyšší s, vyšší l (ale ne úplně křiklavé)
  let tries = 0;
  while(true){
    const h = rand()*360;
    const s = 0.45 + rand()*0.35;   // 45–80 %
    const l = 0.62 + rand()*0.18;   // 62–80 %
    const rgb = hslToRgbArray(h, s, l);  // [R,G,B]



    // vyřaď barvy podobné běžnému pozadí kalkulačky
    if (!isNearForbidden(rgb)) {
      return { h, s, l, rgb };
    }
    if (++tries > 40){
      // nouzový únik – když náhodou padáme jen do zakázané zóny
      return { h, s, l, rgb };
    }
  }
}

function hueDiff(a,b){
 const d = Math.abs(a.h - b.h) % 360;
return d > 180 ? 360 - d : d;
}
function pickNextTargets(rand){
const c1 = randomPastel(rand);
let c2 = randomPastel(rand);
let tries = 0;
 // udrž aspoň ~50° rozestup v hue, ať nejsou obě barvy moc podobné
 while (hueDiff(c1, c2) < 50 && tries++ < 20) c2 = randomPastel(rand);
 return { c1, c2 };
} 
function applyGradient(c1, c2){
  const rgb1 = hslToRgbArray(c1.h, c1.s, c1.l);
  const rgb2 = hslToRgbArray(c2.h, c2.s, c2.l);
  document.documentElement.style.setProperty('--exam-c1', rgbToCss(rgb1));
  document.documentElement.style.setProperty('--exam-c2', rgbToCss(rgb2));
}


function stepExamTween(now){
  if(!tween) return;
  const {start1, start2, end1, end2, t0, dur, rand} = tween;
  let p = (now - t0) / dur;
  if (p >= 1){
    // hotovo – nastav cíl, vygeneruj nový cíl, reset času
    applyGradient(end1, end2);
    const next = pickNextTargets(rand);
    tween.start1 = end1;
    tween.start2 = end2;
    tween.end1 = next.c1;
    tween.end2 = next.c2;
    tween.t0 = now;
     p = 0;
    // nová (náhodná) délka příštího přechodu
    tween.dur = 45000 + Math.floor(rand()*45000);
  }
  const cur1 = lerpHsl(tween.start1, tween.end1, Math.min(Math.max(p,0),1));
  const cur2 = lerpHsl(tween.start2, tween.end2, Math.min(Math.max(p,0),1));
  applyGradient(cur1, cur2);
  examRAF = requestAnimationFrame(stepExamTween);
}

function startExamColorCycleDeterministic(code){
  stopExamColorCycle(); // jistota čistého startu

  const seed = hashCode(String(code||'').toUpperCase());
  const rand = seededRandom(seed);

 // Počáteční barvy: hned náhodné pastely (žádná fixní růžová)
 const first  = pickNextTargets(rand);
 const start1 = first.c1;
 const start2 = first.c2;
 const target = pickNextTargets(rand);
  tween = {
    rand,
    start1, start2,
    end1: target.c1,
    end2: target.c2,
    t0: performance.now(),
   // rychlejší a variabilní: 45–90 s
   dur: 45000 + Math.floor(rand()*45000)
  };

  // nastav okamžitě start, ať UI hned sedí
  applyGradient(start1, start2);

  examRAF = requestAnimationFrame(stepExamTween);
}

function stopExamColorCycle(){
  if (examRAF){ cancelAnimationFrame(examRAF); examRAF = 0; }
  tween = null;
  // vrátit default (necháš klidně růžovou nebo smaž proměnné)
  document.documentElement.style.removeProperty('--exam-c1');
  document.documentElement.style.removeProperty('--exam-c2');
}

function clearForNewEntry(){ if(state.resultShown && !state.editAfterResult){ state.resultShown=false; state.resultStr=''; state.raw=''; state.cursor=0; } }
function insRaw(txt){ clearForNewEntry(); state.raw=state.raw.slice(0,state.cursor)+txt+state.raw.slice(state.cursor); state.cursor+=txt.length; render(); }

/* SMART-DEL bloky */
function smartDeleteUnit(){
  const wrap=document.getElementById('exprWrap');
  if(state.cursor>0 && state.raw[state.cursor-1]==='('){
    let j=state.cursor-2;
    while(j>=0 && /[A-Za-z0-9_#]/.test(state.raw[j])) j--;
    const start=j+1;
    if(start<state.cursor-1){
      state.raw = state.raw.slice(0,start) + state.raw.slice(state.cursor);
      state.cursor = start;
      wrap.scrollLeft=Math.max(0,wrap.scrollLeft-20);
      return true;
    }
  }
  return false;
}
function smartDeleteRootComma(){
  if(!(state.cursor>0 && state.raw[state.cursor-1]===',')) return false;
  let p = state.cursor-2;
  while(p>=0 && /[0-9.+\-Ee]/.test(state.raw[p])) p--;
  if(p>=0 && state.raw[p]==='(' && p>=4 && state.raw.slice(p-4,p)==='root'){
    const y = state.raw.slice(p+1, state.cursor-1);
    state.raw = state.raw.slice(0, p-4) + y + state.raw.slice(state.cursor);
    state.cursor = (p-4) + y.length;
    return true;
  }
  return false;
}

function back(){
  if(smartDeleteRootComma()){ render(); return; }
  if(smartDeleteUnit()){ render(); return; }
  if(state.resultShown && !state.editAfterResult){
    state.resultShown=false; state.resultStr=''; render(); return;
  }
  if(state.cursor<=0){ render(); return; }
  state.raw = state.raw.slice(0,state.cursor-1)+state.raw.slice(state.cursor);
  state.cursor--; render();
}

function moveCursor(step){ if(state.resultShown) state.editAfterResult=true; state.cursor=Math.max(0,Math.min(state.raw.length,state.cursor+step)); render(); }
function ac(hard=false){ state.raw=''; state.cursor=0; if(hard){ state.ans=0; } state.resultShown=false; state.resultStr=''; state.lastRes=null; state.editAfterResult=false; document.getElementById('exprWrap').scrollLeft=0; render(); }

/* ovládací prvky */
onPD(qs('#btnSHIFT'), ()=>{
  if (state.modeStage > 0) { 
    state.modeStage = 0; 
    render(); 
    return; 
  }
  state.shift = !state.shift;
  render();
});

onPD(qs('#btnMODE'), ()=>{ 
  if(state.shift){ state.shift=false; state.ans=0; ac(true); return; }
  state.resultShown=false; state.resultStr='';
  state.modeStage = (state.modeStage===0) ? 1 : (state.modeStage===1 ? 2 : 0);
  render();
});

onPD(qs('#btnLeft'),  ()=> moveCursor(-1));
onPD(qs('#btnRight'), ()=> moveCursor(+1));

onPD(qs('#btnFS'), ()=>{ 
  const doc=document, el=doc.documentElement;
  const inFS=doc.fullscreenElement||doc.webkitFullscreenElement;
  const req=el.requestFullscreen||el.webkitRequestFullscreen;
  const exit=doc.exitFullscreen||doc.webkitExitFullscreen||(()=>Promise.resolve());
  if(inFS){ try{ exit.call(doc); }catch(e){} }
  else{
    if(req){ try{ const p=req.call(el); if(p&&p.catch)p.catch(()=>window.scrollTo(0,1)); }catch(e){ window.scrollTo(0,1); } }
    else { window.scrollTo(0,1); }
  }
  setTimeout(fitToViewport, 120);
});

/* funkční klávesy */
onPD(qs('#btnInv'), ()=>{
  if(state.resultShown && !state.editAfterResult){
    // Po "=", držíme výsledek zobrazený a stavíme na Ans
    state.editAfterResult = true;
    if(state.shift){
      state.shift = false;
      state.raw = 'Ans!';              // faktorál Ans
      state.cursor = state.raw.length;
      render();
    } else {
      state.raw = 'Ans^(-1)';          // převrácená hodnota Ans
      state.cursor = state.raw.length;
      render();
    }
    return;
  }
  // běžné chování při editaci výrazu
  clearForNewEntry();
  if(state.shift){
    state.shift=false;
    if(state.cursor>0 && /[0-9\)]/.test(state.raw[state.cursor-1])) insRaw('!');
    else insRaw('fact(');
  } else {
    insRaw('^(-1)');
  }
});


function insertCP(op){ if(state.resultShown && !state.editAfterResult) return; if(state.cursor===0 || !/[0-9]/.test(state.raw[state.cursor-1])) return; insRaw(op); }
onPD(qs('#btnComb'),()=>{ if(state.shift){ state.shift=false; insertCP('P'); } else insertCP('C'); });

onPD(qs('#btnPolRec'),()=>{ clearForNewEntry(); if(state.shift){ state.shift=false; insRaw('Rec(');} else insRaw('Pol('); });
onPD(qs('#btnPow3'),()=>{
  if(state.resultShown && !state.editAfterResult){
    state.editAfterResult = true;
    if(state.shift){
      state.shift=false;
      state.raw = 'cbrt(Ans)';        // ∛(Ans)
      state.cursor = state.raw.length;
      render();
    } else {
      state.raw = 'Ans^(3)';          // Ans^3
      state.cursor = state.raw.length;
      render();
    }
    return;
  }
  clearForNewEntry();
  if(state.shift){ state.shift=false; insRaw('cbrt(');} else insRaw('^(3)');
});

onPD(qs('#btnFracKey'), ()=>{
  if(state.resultShown){
    if(state.shift){
      state.shift=false;
      state.frac = true;
      state.fracMixed = false;
    }else{
      if(!state.frac){ state.frac=true; state.fracMixed=true; }
      else if(state.frac && state.fracMixed){ state.frac=false; }
      else { state.frac=true; state.fracMixed=true; }
    }
    updateResultView(); render();
    return;
  }
  clearForNewEntry();
  state.shift=false;
  insRaw('∟');
});

onPD(qs('#btnSqrt'),()=>{ clearForNewEntry(); insRaw('sqrt('); });
onPD(qs('#btnPow2'),()=>{
  if(state.resultShown && !state.editAfterResult){
    state.editAfterResult = true;
    state.raw = 'Ans^(2)';            // Ans^2
    state.cursor = state.raw.length;
    render();
    return;
  }
  clearForNewEntry();
  insRaw('^(2)');
});


onPD(qs('#btnPow'), ()=>{ 
  if(state.shift){
    state.shift=false;
    let i=state.cursor-1,start=i+1; while(i>=0&&/[0-9.]/.test(state.raw[i])) i--; start=i+1;
    const y=state.raw.slice(start,state.cursor);
    if(y){ state.raw=state.raw.slice(0,start)+state.raw.slice(state.cursor); state.cursor=start; insRaw('root('+y+','); }
    else  insRaw('root(');
  }else{ opAfterResult('^'); }
});
onPD(qs('#btnHYP'), ()=>{ state.hyp=!state.hyp; render(); });
onPD(qs('#btnNeg'), ()=> insRaw('−'));

onPD(qs('#btnDMSsym'),()=>{
  // Pokud je zobrazen výsledek a nezačali jsme editovat, přepínej DMS <-> desetinný
  if(state.resultShown && !state.editAfterResult){
    state.dmsDisplay = !state.dmsDisplay;
    updateResultView();
    return;
  }

  // Rozsah pouze v aktuálním "členu" za posledním operátorem nebo levou závorkou
  const ops = ['+', '−', '×', '÷', ',', '('];
  const beforeAll = state.raw.slice(0, state.cursor);
  let segStart = 0;
  for (const op of ops) {
    const idx = beforeAll.lastIndexOf(op);
    if (idx >= segStart) segStart = idx + 1;
  }
  const scope = beforeAll.slice(segStart);

  // SHIFT může vynutit konkrétní symboly (zpětná kompatibilita)
  if(state.shift && state.hyp){ state.shift=false; insRaw('″'); return; }
  if(state.shift){ state.shift=false; insRaw('′'); return; }

  const lastDeg = scope.lastIndexOf('°');
  const lastMin = scope.lastIndexOf('′');
  const lastSec = scope.lastIndexOf('″');

  // 1) v aktuálním členu ještě nebyl "°" → vlož "° "
  if(lastDeg === -1){
    insRaw('° ');
    return;
  }
  // 2) máme "°", ale ne "′" → vlož "′ "
  if(lastMin < lastDeg){
    insRaw('′ ');
    return;
  }
  // 3) máme i "′", ale ne "″" → vlož "″"
  if(lastSec < lastMin){
    insRaw('″');
    return;
  }
  // 4) kompletní trojice je hotová → začni novou DMS sekvenci v tomto členu
  insRaw(' ° ');
});


onPD(qs('#btnRCLSTO'),()=>{ if(state.shift){ state.shift=false; state.memory= +state.ans || 0; state.memOn=state.memory!==0; render(); } else insRaw(String(state.memory)); });
onPD(qs('#btnENG'),()=>{ state.eng=!state.eng; if(state.resultShown) updateResultView(); render(); });
onPD(qs('#btnMpm'),()=>{ if(state.shift){ state.shift=false; state.memory -= (+state.ans||0); } else { state.memory += (+state.ans||0); } state.memOn=state.memory!==0; render(); });

onPDAll('[data-fn]', el=>{ clearForNewEntry(); const f=el.dataset.fn; if(f==='log'){ if(state.shift){ state.shift=false; insRaw('pow10('); } else insRaw('log('); } if(f==='ln'){ if(state.shift){ state.shift=false; insRaw('exp('); } else insRaw('ln('); }});

onPDAll('[data-trig]', el=>{
  clearForNewEntry();
  const base=el.dataset.trig; let raw='';
  if(state.shift && !state.hyp){ raw='a'+base+'('; }
  else if(state.shift && state.hyp){ raw='a'+base+'h('; }
  else if(state.hyp){ raw=base+'h('; }
  else{ raw=base+'('; }
  state.shift=false; insRaw(raw);
});

onPD(qs('#btn0'),  ()=>{ if(state.shift){ state.shift=false; insRaw('Rnd(');} else insRaw('0'); });
onPD(qs('#btnDot'),()=>{
  if(state.shift){
    state.shift=false;
    insRaw('RAN#');       // bez závorek
  } else {
    insRaw('.');
  }
});

onPD(qs('#btnEXP'),()=>{ if(state.shift){ state.shift=false; insRaw('π'); } else insRaw('E'); });
onPD(qs('#btnAns'),()=>{ if(state.shift){ state.shift=false; state.drg = state.drg==='DEG'?'RAD':state.drg==='RAD'?'GRAD':'DEG'; if(state.resultShown) updateResultView(); render(); } else insRaw('Ans'); });
onPD(qs('#btnEq'), ()=>{ 
  if(state.shift){ state.shift=false; insRaw('%'); return; }
  if(state.resultShown && !state.editAfterResult && state.repeat){
    const sym = prettyOp(state.repeat.op);
    state.raw = 'Ans' + sym + String(state.repeat.rhs);
    state.cursor = state.raw.length;
  }
  evaluate();
});

onPDAll('[data-act]', el=>{ const a=el.dataset.act; if(a==='del') back(); else if(a==='ac') ac(); });

function opAfterResult(sym){
  if(state.resultShown && !state.editAfterResult){
    // Necháme výsledek viditelný, jen začneme nový výraz "Ans <op>"
    state.editAfterResult = true;
    state.raw = 'Ans' + sym;
    state.cursor = state.raw.length;
    render();
  } else {
    insRaw(sym);
  }
}


onPDAll('[data-ins]', el=>{
  const t=el.dataset.ins;
  if(state.modeStage>0 && /^[0-9]$/.test(t)){ handleMenuChoice(t); return; }

  if(t==='+'||t==='−'||t==='×'||t==='÷'){ opAfterResult(t); }
  else if(t==='('||t===')'||t===','||/^[0-9.]$/.test(t)){ insRaw(t); }
  else { insRaw(t); }
});
function prettyOp(op){ return op==='+'?'+': op==='-'?'−': op==='*'?'×': op==='/'?'÷': op; }

function captureRepeat(tokens){
  const n = tokens.length;
  if(n<3 || tokens[n-1].type!=='num'){ state.repeat=null; return; }
  let i = n-2;
  while(i>=0 && !(tokens[i].type==='op' && ['+','-','*','/','^'].includes(tokens[i].op))) i--;
  if(i<0){ state.repeat=null; return; }
  state.repeat = { op: tokens[i].op, rhs: tokens[n-1].value };
}
/* ===== parser ===== */
function normalizeInput(s){
  s=s.replace(/\s+/g,'').replace(/×/g,'*').replace(/÷/g,'/').replace(/−/g,'-');
  s = s.replace(/RAN#(?!\s*\()/g, 'RAN#()'); // RAN# → RAN#() pokud nemá ( )
  s=autoCloseUnary(s);
  s=autoCloseRoot(s);

  const sep    = '[∟]'; // pouze náš symbol, žádné "L" apod.
  const mixRe  = new RegExp(`(^|[^0-9.])(-?\\d+)${sep}(\\d+)${sep}(\\d+)(?![0-9.])`, 'g');
  const fracRe = new RegExp(`(^|[^0-9.])(-?\\d+)${sep}(\\d+)(?![0-9.])`, 'g');

  let prev;
  do {
    prev = s;
    s = s.replace(mixRe,  (_m, pre, a, b, c) => `${pre}(${a}+(${b})/(${c}))`);
  } while (prev !== s);

  s = s.replace(fracRe, (_m, pre, n, d) => `${pre}((${n})/(${d}))`);
  s = s.replace(/\s+/g,'');

  s=s.replace(/sin\^\(-1\)\(/g,'asin(').replace(/cos\^\(-1\)\(/g,'acos(').replace(/tan\^\(-1\)\(/g,'atan(');
  s=s.replace(/Ans/g,String(state.ans)).replace(/π/g,String(Math.PI));
  // plné DMS: d ° m ′ s ″
s = s.replace(
  /(-?\d+(?:\.\d+)?)°\s*(\d+(?:\.\d+)?)′\s*(\d+(?:\.\d+)?)″/g,
  (_, d, m, sec) => String(dmsToDeg(parseFloat(d), parseFloat(m), parseFloat(sec)))
);
// jen stupně + minuty: doplň sekundy = 0
s = s.replace(
  /(-?\d+(?:\.\d+)?)°\s*(\d+(?:\.\d+)?)′/g,
  (_, d, m) => String(dmsToDeg(parseFloat(d), parseFloat(m), 0))
);
// jen stupně: doplň minuty = 0, sekundy = 0
// (není-li bezprostředně po ° další DMS symbol nebo číslo minut)
s = s.replace(
  /(-?\d+(?:\.\d+)?)°(?!\s*[\d′″])/g,
  (_, d) => String(dmsToDeg(parseFloat(d), 0, 0))
);

  s=s.replace(/(-?\d+(?:\.\d+)?)C(-?\d+(?:\.\d+)?)/g,'nCr($1,$2)');
  s=s.replace(/(-?\d+(?:\.\d+)?)P(-?\d+(?:\.\d+)?)/g,'nPr($1,$2)');
  return s;
}

function autoCloseUnary(s){
  const unary=['sin','cos','tan','asin','acos','atan','sinh','cosh','tanh','asinh','acosh','atanh',
               'sqrt','cbrt','log','ln','exp','pow10','abs','ceil','floor','inv','Rnd'];
  let out='', i=0;

  while(i<s.length){
    let name=null;
    for(const n of unary){ if(s.startsWith(n+'(', i)){ name=n; break; } }
    if(!name){ out+=s[i++]; continue; }

    const open = i + name.length;

    let depth=0, j=open;
    if(s[open]==='('){
      depth=1; j=open+1;
      while(j<s.length && depth>0){
        if(s[j]==='(') depth++;
        else if(s[j]===')') depth--;
        j++;
      }
      if(depth===0){ out += s.slice(i, j); i = j; continue; }
    }

    out += name+'(';
    i = open+1;
    let k=i;

    if(s[k]=='+'||s[k]=='-') k++;
    while(k<s.length && /[0-9.]/.test(s[k])) k++;
    while(k<s.length && (s[k]==='°'||s[k]==='′'||s[k]==='″')) k++;
    if((s[k]==='E'||s[k]==='e') && /[-+0-9]/.test(s[k+1])){
      k++; if(s[k]=='+'||s[k]=='-') k++;
      while(k<s.length && /[0-9]/.test(s[k])) k++;
    }

    if(k>=s.length){ out += s.slice(i,k)+')'; i=k; }
    else if(s[k]===')'){ out += s.slice(i,k+1); i=k+1; }
    else if('+-*/^,'.includes(s[k])){ out += s.slice(i,k)+')'+s[k]; i=k+1; }
    else { out += s[i]; i++; }
  }
  return out;
}

function autoCloseRoot(s){
  let out='', i=0;
  while(i<s.length){
    if(s.startsWith('root(', i)){
      const open = i + 4;
      let depth=1, j=open+1;
      while(j<s.length && depth>0){
        if(s[j]==='(') depth++;
        else if(s[j]===')') depth--;
        j++;
      }
      if(depth===0){ out += s.slice(i, j); i = j; continue; }

      out += 'root(';
      i = open+1;

      let a=i;
      if(s[a]=='+'||s[a]=='-') a++;
      while(a<s.length && /[0-9.]/.test(s[a])) a++;
      if((s[a]==='E'||s[a]==='e') && /[-+0-9]/.test(s[a+1])){
        a++; if(s[a]=='+'||s[a]=='-') a++; while(a<s.length && /[0-9]/.test(s[a])) a++;
      }
      if(s[a]!==','){ out+=s[i]; i++; continue; }
      out += s.slice(i, a+1);
      i = a+1;

      let b=i;
      if(s[b]=='+'||s[b]=='-') b++;
      while(b<s.length && /[0-9.]/.test(s[b])) b++;
      if((s[b]==='E'||s[b]==='e') && /[-+0-9]/.test(s[b+1])){
        b++; if(s[b]=='+'||s[b]=='-') b++; while(b<s.length && /[0-9]/.test(s[b])) b++;
      }

      if(b>=s.length){ out += s.slice(i,b) + ')'; i=b; }
      else if(s[b]===')'){ out += s.slice(i,b+1); i=b+1; }
      else if('+-*/^,'.includes(s[b])){ out += s.slice(i,b) + ')' + s[b]; i=b+1; }
      else { out += s[i]; i++; }
      continue;
    }
    out += s[i++];
  }
  return out;
}

function tokenize(s){
  const t=[];let i=0;const dig=c=>/[0-9]/.test(c), lettr=c=>/[A-Za-z#]/.test(c);
  while(i<s.length){
    const c=s[i];
    if(dig(c)||(c==='.'&&dig(s[i+1]))){
      let j=i+1, num=c;
      while(j<s.length&&/[0-9.]/.test(s[j])) num+=s[j++];
      if((s[j]==='E'||s[j]==='e')&&/[-+0-9]/.test(s[j+1])){
        num+=s[j++]; if(s[j]=='+'||s[j]=='-') num+=s[j++]; while(j<s.length&&/[0-9]/.test(s[j])) num+=s[j++];
      }
      t.push({type:'num',value:+num}); i=j; continue;
    }
    if(lettr(c)){ let j=i+1, id=c; while(j<s.length&&/[A-Za-z0-9_#]/.test(s[j])) id+=s[j++]; t.push({type:'id',value:id}); i=j; continue; }
    if(c==='('||c===')'||c===','){ t.push({type:c}); i++; continue; }
    if(c==='+'||c==='-'||c==='*'||c==='/'||c==='^'){ t.push({type:'op',op:c}); i++; continue; }
    if(c==='!'||c==='%'){ t.push({type:'post',op:c}); i++; continue; }
    throw Error('Neznámý znak: '+c);
  }
  return t;
}
function toRPN(tokens){
  const out=[], ops=[], argc=[];
  const prec={'unary-':5,'^':4,'*':3,'/':3,'mod':3,'+':2,'-':2,'!':6,'%':6};
  const right={'^':1};
  let prev='start';
  for(const t of tokens){
    if(t.type==='num'){ out.push(t); prev='num'; continue; }
    if(t.type==='id'){
      if(t.value==='mod'){
        while(ops.length){
          const top=ops[ops.length-1];
          if(top.type==='op'&&( (prec[top.op]>prec.mod) || (prec[top.op]===prec.mod && !right[top.op]) )) out.push(ops.pop());
          else break;
        }
        ops.push({type:'op',op:'mod'}); prev='op'; continue;
      }
      ops.push({type:'func',name:t.value}); prev='func'; continue;
    }
    if(t.type==='op'){
      if(t.op==='-'&&(prev==='start'||prev==='op'||prev==='('||prev==='comma')){
        const u={type:'op',op:'unary-'};
        while(ops.length&&ops[ops.length-1].type==='op'&&prec[ops[ops.length-1].op]>prec[u.op]) out.push(ops.pop());
        ops.push(u);
      }else{
        while(ops.length){
          const top=ops[ops.length-1];
          if(top.type==='op'&&(prec[top.op]>prec[t.op]||(prec[top.op]===prec[t.op]&&!right[top.op]))) out.push(ops.pop());
          else break;
        }
        ops.push({type:'op',op:t.op});
      }
      prev='op'; continue;
    }
    if(t.type==='post'){
      const p={type:'op',op:t.op==='!'?'!':'%post'};
      while(ops.length&&ops[ops.length-1].type==='op'&&prec[ops[ops.length-1].op]>prec['!']) out.push(ops.pop());
      ops.push(p); prev='post'; continue;
    }
    if(t.type==='('){ ops.push(t); argc.push(1); prev='('; continue; }
    if(t.type===','){ while(ops.length&&ops[ops.length-1].type!=='(') out.push(ops.pop()); if(argc.length) argc[argc.length-1]++; prev='comma'; continue; }
    if(t.type===')'){
      while(ops.length&&ops[ops.length-1].type!=='(') out.push(ops.pop());
      if(!ops.length) throw Error('Chybí "("');
      ops.pop(); const n=argc.pop()||1;
      if(ops.length&&ops[ops.length-1].type==='func'){ const f=ops.pop(); out.push({type:'func',name:f.name,argc:n}); }
      prev=')'; continue;
    }
  }
  while(ops.length){
    const x=ops.pop();
    if(x.type==='(') throw Error('Chybí ")"');
    if(x.type==='func') out.push({type:'func',name:x.name,argc:1}); else out.push(x);
  }
  return out;
}
function evalRPN(rpn){
  const st=[];
  const toRad=v=>state.drg==='DEG'?v*Math.PI/180:state.drg==='GRAD'?v*Math.PI/200:v;
  const fromRad=r=>state.drg==='DEG'?r*180/Math.PI:state.drg==='GRAD'?r*200/Math.PI:r;
const map={
  // goniometrie – výstup “zacvakneme” na 0/±1 kvůli plovoucí čárce
  sin:a=>cleanTrig(Math.sin(toRad(a))),
  cos:a=>cleanTrig(Math.cos(toRad(a))),
  tan:a=>cleanTrig(Math.tan(toRad(a))),

  // inverzní – vstup zacvaknout do [-1,1]; výsledek podle DRG
  asin:a=>fromRad(Math.asin(clampUnit(a))),
  acos:a=>fromRad(Math.acos(clampUnit(a))),
  atan:a=>fromRad(Math.atan(a)),

  // hyperbolické – volitelné zacvaknutí (tanh ~ ±1, sinh ~ 0)
  sinh:a=>cleanTrig(Math.sinh(a)),
  cosh:a=>cleanTrig(Math.cosh(a)),
  tanh:a=>cleanTrig(Math.tanh(a)),

  asinh:a=>Math.asinh(a), acosh:a=>Math.acosh(a), atanh:a=>Math.atanh(a),

  log:a=>Math.log10(a), ln:a=>Math.log(a), exp:a=>Math.exp(a),
  sqrt:a=>Math.sqrt(a), cbrt:a=>Math.cbrt(a), root:(y,x)=>x**(1/y),
  abs:a=>Math.abs(a), ceil:a=>Math.ceil(a), floor:a=>Math.floor(a), inv:a=>1/a,
  pow10:a=>10**a, pow:(a,b)=>a**b, nCr:(n,r)=>comb(n,r), nPr:(n,r)=>perm(n,r),
  gcd:(a,b)=>gcd(a,b), lcm:(a,b)=>lcm(a,b), mod:(a,b)=>mod(a,b),
  'RAN#':()=>Math.random(), Rnd:a=>roundSig(a,10),

  Pol:(x,y)=>({t:'pair',a:Math.hypot(x,y),b:fromRad(Math.atan2(y,x))}),
  Rec:(r,th)=>{const rad=toRad(th);return{t:'pair',a:r*Math.cos(rad),b:r*Math.sin(rad)};},

  DMS:a=>({t:'dms',v:a}),
  fact:a=>fact(a)
};

  for(const t of rpn){
    if(t.type==='num'){ st.push(t.value); continue; }
    if(t.type==='op'){
      if(t.op==='unary-'){ st.push(-st.pop()); continue; }
      if(t.op==='!'){ st.push(fact(st.pop())); continue; }
      if(t.op==='%post'){ st.push(st.pop()/100); continue; }
      const b=st.pop(), a=st.pop();
      st.push(t.op==='+'?a+b:t.op==='-'?a-b:t.op==='*'?a*b:t.op==='/'?a/b:t.op==='^'?a**b:mod(a,b));
      continue;
    }
    if(t.type==='func'){ const args=[]; for(let i=0;i<t.argc;i++) args.unshift(st.pop()); st.push(map[t.name](...args)); continue; }
  }
  if(st.length!==1) throw Error('Chybný výraz'); return st[0];
}

/* pomocné */
function fact(n){ n=Math.round(n); if(n<0) return NaN; if(n>170) return Infinity; let r=1; for(let i=2;i<=n;i++) r*=i; return r; }
function gcd(a,b){ a=Math.trunc(Math.abs(a)); b=Math.trunc(Math.abs(b)); if(a===0)return b; if(b===0)return a; while(b){ const t=b; b=a%b; a=t; } return a; }
function lcm(a,b){ a=Math.trunc(a); b=Math.trunc(b); return a&&b?Math.abs(a*b)/gcd(a,b):0; }
function mod(a,b){ if(b===0) return NaN; return a-b*Math.floor(a/b); }
function comb(n,r){ n=Math.round(n); r=Math.round(r); if(r<0||n<0||r>n) return NaN; r=Math.min(r,n-r); let num=1,den=1; for(let i=1;i<=r;i++){ num*=n-r+i; den*=i; } return num/den; }
function perm(n,r){ n=Math.round(n); r=Math.round(r); if(r<0||n<0||r>n) return NaN; let p=1; for(let i=0;i<r;i++) p*=(n-i); return p; }
function roundSig(x,n=12){ if(!isFinite(x)) return x; if(x===0) return 0; const d=Math.ceil(Math.log10(Math.abs(x))); const p=n-d; const m=10**p; return Math.round(x*m)/m; }
function stripZeros(s){ return s.replace(/(\.\d*?[1-9])0+$/,'$1').replace(/\.0+$/,'').replace(/^-0$/,'0'); }
function clampUnit(x, eps=1e-12){
  if (x > 1 && x < 1 + eps) return 1;
  if (x < -1 && x > -1 - eps) return -1;
  return x;
}
// zacvakni výstup trig funkcí na 0 / ±1, když je to “téměř” ono
function cleanTrig(x, eps=1e-12){
  if (!isFinite(x)) return x;
  if (Math.abs(x) < eps) return 0;
  if (Math.abs(x - 1) < eps) return 1;
  if (Math.abs(x + 1) < eps) return -1;
  return x;
}
  function toEngineering(x){
  if(!isFinite(x)) return String(x);
  if(x===0) return '0';
  const e=Math.floor(Math.log10(Math.abs(x)));
  const E=Math.floor(e/3)*3;
  const m=x/10**E;
  const mant = stripZeros(m.toPrecision(9));
  return `<span class="sci">${mant}<span class="times">×</span><span class="ten">10</span><sup class="exp">${E}</sup></span>`;
}
function toScientificAuto(x){
  if(!isFinite(x)) return String(x);
  if(x===0) return '0';
  let e = Math.floor(Math.log10(Math.abs(x)));
  let m = x / 10**e;
  let mant = stripZeros(m.toPrecision(9));
  if(Math.abs(+mant) >= 10){
    e += 1;
    m /= 10;
    mant = stripZeros(m.toPrecision(9));
  }
  return `<span class="sci">${mant}<span class="times">×</span><span class="ten">10</span><sup class="exp">${e}</sup></span>`;
}
function toFractionStr(x, mixed=true, maxDen=1e6){
  if(!isFinite(x)) return String(x);
  const sign = x<0 ? -1 : 1;
  let a = Math.abs(x);
  let w = Math.floor(a), f = a - w;
  if(f === 0) return (sign<0?'-':'') + String(w);
  let h1=1,h0=0,k1=0,k0=1,b=f;
  while(true){
    let A=Math.floor(b), h2=A*h1+h0, k2=A*k1+k0;
    if(k2>maxDen) break;
    h0=h1; k0=k1; h1=h2; k1=k2;
    const diff=Math.abs(f - h1/k1);
    if(diff<1e-12 || !isFinite(1/(b-A))) break;
    b = 1/(b-A);
  }
  let num=h1, den=k1;
  if(!mixed){ num = w*den + num; w = 0; }
  const body = (w ? (w + ' ∟ ' + num + ' ∟ ' + den) : (num + ' ∟ ' + den));
  return (sign<0?'-':'') + body;
}
function degToDMS(x){
  const sign = x < 0 ? -1 : 1;
  x = Math.abs(x);

  let d = Math.floor(x);
  let mf = (x - d) * 60;
  let m = Math.floor(mf);
  let s = (mf - m) * 60;

  // zaokrouhlení sekund + normalizace přenosu 60″ → +1′, 60′ → +1°
  s = Math.round(s * 1e6) / 1e6;         // přesnost na 1e-6 s
  if (s >= 60) { s -= 60; m += 1; }
  if (m >= 60) { m -= 60; d += 1; }

  const prefix = sign < 0 ? '-' : '';
  return prefix + d + '°' + m + '′' + stripZeros(String(s)) + '″';
}

function dmsToDeg(d,m,s){ const sign=d<0?-1:1; d=Math.abs(d); return sign*(d+m/60+s/3600); }

function formatNumWithOptions(v){
  if(!isFinite(v)) return String(v);
  const x = roundSig(v,12);

  if(state.dmsDisplay) return degToDMS(x);
  if(state.eng)        return toEngineering(x);
  if(state.frac)       return toFractionStr(x,state.fracMixed);

  const ax = Math.abs(x);
  // Malé/velké hodnoty: vždy hezká vědecká notace
  if(ax !== 0 && (ax >= 1e8 || ax < 1e-8)){
    return toScientificAuto(x);
  }

  // Jinak použijeme toPrecision – ale pokud by vrátilo e-zápis,
  // vynutíme naši vědeckou notaci s ×10^
  const s = stripZeros(x.toPrecision(12));
  if (/[eE]/.test(s)) {
    return toScientificAuto(x);
  }
  return s;
}

function updateResultView(){
  if(!state.lastRes){ state.resultStr=''; state.resultShown=false; render(); return; }
  if(state.lastRes.type==='num'){ state.resultStr = formatNumWithOptions(state.lastRes.v); }
  else if(state.lastRes.type==='pair'){ state.resultStr = `(${formatNumWithOptions(state.lastRes.a)}, ${formatNumWithOptions(state.lastRes.b)})`; }
  state.resultShown=true; render();
}
function evaluate(){
  try{
    const hadSep = /[∟]/.test(state.raw);
const hadDMS = /[°′″]/.test(state.raw);
const norm = normalizeInput(state.raw);

    const toks = tokenize(norm);
    const rpn  = toRPN(toks);
    let res    = evalRPN(rpn);

    if(res && res.t==='pair'){
      state.ans=NaN; state.lastRes={type:'pair',a:+res.a,b:+res.b}; state.repeat=null;
    }else if(res && res.t==='dms'){
      state.ans=+res.v; state.lastRes={type:'num',v:+res.v}; state.dmsDisplay=true; state.repeat=null;
    }else{
      state.ans=+res; state.lastRes={type:'num',v:+res}; captureRepeat(toks);
    }

    if(hadSep){ state.frac=true; state.fracMixed=true; }
else { state.frac=false; }

// Pokud uživatel psal DMS, ukaž výsledek rovnou ve stupních-minutách-vteřinách
if(hadDMS){ state.dmsDisplay = true; }

state.editAfterResult=false;
updateResultView();

  }catch(_){
    state.lastRes=null; state.resultStr='Error';
    state.resultShown=true; state.editAfterResult=false; state.repeat=null; render();
  }
}

/* init */
render();
fitToViewport();
updateExamUI();

/* klávesnice */
addEventListener('keydown',e=>{
  const k=e.key;
  if(k==='L'){ insRaw('∟'); return; }
  if(k==='Enter'){e.preventDefault();evaluate();return;}
  if(k==='Backspace'){e.preventDefault();back();return;}
  if(k==='Escape'){e.preventDefault();ac();return;}
  if(k==='ArrowLeft'){e.preventDefault();moveCursor(-1);return;}
  if(k==='ArrowRight'){e.preventDefault();moveCursor(+1);return;}
  if(/^[0-9]$/.test(k)){
    if(state.modeStage>0){ handleMenuChoice(k); }
    else { insRaw(k); }
    return;
  }

  if(k==='('||k===')'||k===','||k==='.'||k==='%'){insRaw(k);return;}
  if(k==='^'){opAfterResult('^');return;}
  if(k==='+'){opAfterResult('+');return;}
  if(k==='-'){opAfterResult('−');return;}
  if(k==='*'){opAfterResult('×');return;}
  if(k==='/'){opAfterResult('÷');return;}
  if(k==='e'){insRaw('E');return;}
});
</script>

<script>
  if ('serviceWorker' in navigator) {
    const SW_URL = './sw.js?v=2025-09-27b'; // zvyšuj verzi při deployi
    const FLAG = 'updateReady';

    const ui = {
      bar: null, btn: null,
      show() {
        if (!this.bar) {
          this.bar = document.createElement('div');
          this.bar.style.cssText = 'position:fixed;left:0;right:0;bottom:0;background:#111827;color:#fff;padding:10px 14px;display:flex;gap:10px;align-items:center;z-index:99999';
          this.bar.innerHTML = '<span>Je dostupná nová verze.</span>';
          this.btn = document.createElement('button');
          this.btn.textContent = 'Aktualizovat';
          this.btn.style.cssText = 'margin-left:auto;background:#10b981;border:none;color:#fff;padding:8px 12px;border-radius:8px;cursor:pointer';
          this.bar.appendChild(this.btn);
          document.body.appendChild(this.bar);
          this.btn.addEventListener('click', () => {
            // aktivuj novou verzi
            if (window.__swWaiting) {
              window.__swWaiting.postMessage({ type: 'SKIP_WAITING' });
            }
          });
        }
        this.bar.style.display = 'flex';
      },
      hide() { if (this.bar) this.bar.style.display = 'none'; }
    };

    function markReady(on) {
      try { localStorage.setItem(FLAG, on ? '1' : ''); } catch {}
    }
    function isMarked() {
      try { return localStorage.getItem(FLAG) === '1'; } catch { return false; }
    }

    window.addEventListener('load', async () => {
      try {
        const reg = await navigator.serviceWorker.register(SW_URL, { scope: './' });

        // Každé spuštění aktivně zkusí najít update
        reg.update().catch(()=>{});

        // Když se objeví nová verze:
        reg.addEventListener('updatefound', () => {
          const sw = reg.installing;
          if (!sw) return;
          sw.addEventListener('statechange', () => {
            if (sw.state === 'installed' && navigator.serviceWorker.controller) {
              // Nová verze je připravená (waiting)
              window.__swWaiting = reg.waiting || sw; // cache waiting
              markReady(true);
              ui.show();
            }
          });
        });

        // Pokud je čekající verze už teď (třeba po reloadu)
        if (reg.waiting) {
          window.__swWaiting = reg.waiting;
          markReady(true);
          ui.show();
        } else if (isMarked()) {
          // Bezpečnostní síť: když máme flag, ale waiting není → ještě jednou update()
          reg.update().catch(()=>{});
        }

        // Když se aktivuje nový controller (po SKIP_WAITING) → reload
        navigator.serviceWorker.addEventListener('controllerchange', () => {
          markReady(false);
          location.reload();
        });

        // Pokud při dalším spuštění už běží nová verze, flag smažeme (není co nabízet)
        if (!navigator.serviceWorker.controller) {
          // první instalace – žádná lišta
          markReady(false);
        }
      } catch (e) {
        console.warn('SW reg failed', e);
      }
    });
  }
</script>



<!-- QR overlay (statický náhled) -->
<div id="qrBackdrop" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.6);place-items:center;z-index:9999">
  <div style="background:#fff;border-radius:16px;padding:16px;color:#111;text-align:center">
    <img id="qrImg" src="./icons/qr.png?v=2" alt="QR kód" width="280" height="280">
    <div id="qrUrl" style="font:14px/1.2 ui-sans-serif,system-ui,Segoe UI,Roboto;margin-top:8px;word-break:break-all"></div>
  </div>
</div>
<script>
(() => {
  if (window.__qrInit) return; window.__qrInit = true;
  const qrBackdrop = document.getElementById('qrBackdrop');
  const btnQR = document.getElementById('btnQR');
  const qrUrl = document.getElementById('qrUrl');

  function isOpen(){ return qrBackdrop && qrBackdrop.style.display !== 'none'; }
  function openQR(){
    if (!qrBackdrop) return;
    qrBackdrop.style.display = 'grid';
    if(qrUrl) qrUrl.textContent = location.href;
    if (location.hash !== '#qr') history.pushState({ qr: true }, '', '#qr');
  }
  function closeQR(){
    if (!qrBackdrop) return;
    qrBackdrop.style.display = 'none';
    if (location.hash === '#qr') history.back();
  }

  btnQR && btnQR.addEventListener('pointerdown', openQR, { passive: true });
  qrBackdrop && qrBackdrop.addEventListener('pointerdown', (e) => { if (e.target === qrBackdrop) closeQR(); }, { passive: true });
  window.addEventListener('keydown', (e) => { if (e.key === 'Escape' && isOpen()) closeQR(); });
  window.addEventListener('popstate', () => { if (location.hash !== '#qr' && qrBackdrop) qrBackdrop.style.display = 'none'; });
  if (location.hash === '#qr') { history.replaceState(null, '', location.pathname + location.search); if (qrBackdrop) qrBackdrop.style.display = 'none'; }
})();
</script>

<!-- QR SCANNER (START/END) -->
<script>
const QR = (()=> {
  let overlay, video, note, running=false, stopCb=null;
function parseExamPayload(text){
  // 1) nativní JSON {"v":1,"payload":"{...}"}
  try {
    const outer = JSON.parse(text);
    if (outer && outer.payload) {
      const inner = JSON.parse(outer.payload);
      return inner; // očekáváme { type, code, ts, expSec }
    }
  } catch {}

  // 2) URL s ?payload=... (URL-encoded JSON)
  try {
    if (/^https?:\/\//i.test(text)) {
      const u = new URL(text);
      const p = u.searchParams.get('payload') || u.searchParams.get('p') || u.hash.replace(/^#/, '');
      if (p) {
        const inner = JSON.parse(decodeURIComponent(p));
        return inner;
      }
      // 2b) fajnový fallback: ?code=XYZ&type=START&ts=...&expSec=...
      const code = u.searchParams.get('code');
      const type = (u.searchParams.get('type') || 'START').toUpperCase();
      const ts = +(u.searchParams.get('ts') || 0);
      const expSec = +(u.searchParams.get('expSec') || 0);
      if (code) return { code, type, ts, expSec };
    }
  } catch {}

  // 3) "CODE|TYPE|TS|EXP" (např. "A7K|START|1730000000|900")
  if (/^[A-Za-z0-9]{1,8}\|/i.test(text)) {
    const [code, type='START', ts='0', expSec='0'] = text.split('|');
    return { code, type: String(type).toUpperCase(), ts: +ts, expSec: +expSec };
  }

  return null;
}

  function buildUI(){
    if(overlay) return;
    overlay = document.createElement('div');
    overlay.style.cssText = "position:fixed;inset:0;background:rgba(0,0,0,.88);display:none;z-index:99998;color:#fff";
    const box = document.createElement('div');
    box.style.cssText="position:absolute;inset:0;display:grid;place-items:center;padding:14px";
    video = document.createElement('video');
    video.setAttribute('playsinline','');
    video.style.cssText="max-width:96vw;max-height:60vh;border:2px solid #7dd3fc;border-radius:12px;background:#000";
    note = document.createElement('div');
    note.style.cssText="margin-top:10px;font:600 16px/1.4 system-ui,Segoe UI,Roboto;text-align:center";
    const btnX=document.createElement('button');
    btnX.textContent="Zavřít";
    btnX.onclick = stop;
    btnX.style.cssText="position:absolute;top:10px;right:10px;background:#ef4444;border:none;color:#fff;padding:8px 12px;border-radius:8px";
    box.appendChild(video); box.appendChild(note); overlay.appendChild(box); overlay.appendChild(btnX);
    document.body.appendChild(overlay);
  }

  async function ensureFallback(){
    if('BarcodeDetector' in window) return null;
    if(window.ZXing) return window.ZXing;
    // Preferuj lokální build (funguje i offline v PWA). Pokud chybí, poslední šance CDN.
    try {
      await new Promise((res,rej)=>{ const s=document.createElement('script'); s.src="./vendor/zxing.min.js"; s.onload=res; s.onerror=rej; document.head.appendChild(s); });
      return window.ZXing;
    } catch(_) {
      await new Promise((res,rej)=>{ const s=document.createElement('script'); s.src="https://cdn.jsdelivr.net/npm/@zxing/library@0.20.0/umd/index.min.js"; s.onload=res; s.onerror=rej; document.head.appendChild(s); });
      return window.ZXing;
    }
  }

  async function start(kind){ // kind: 'START' | 'END'
    if(running) return;
    buildUI();
    overlay.style.display='block';
    note.textContent = kind==='START' ? "Namiřte na START QR…" : "Namiřte na END QR…";
    running=true;

    let stream=null;
    try{
      stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'environment' }, audio:false });
    }catch(e){
      note.textContent = "Kameru se nepodařilo otevřít. Povolte přístup kameře.";
      running=false; return;
    }
    video.srcObject = stream; await video.play();

    const useBD = ('BarcodeDetector' in window);
    let detector = null;
    if(useBD){ detector = new BarcodeDetector({ formats: ['qr_code'] }); }
    else { await ensureFallback(); }

    let raf=0;
    const canvas = document.createElement('canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently:true });

    async function tick(){
      if(!running) return;
      try{
        let text=null;
        if(useBD){
          const codes = await detector.detect(video);
          if(codes && codes[0]) text = codes[0].rawValue || codes[0].rawValueText || codes[0].rawValueString;
        }else if(window.ZXing){
          canvas.width = video.videoWidth; canvas.height = video.videoHeight;
          ctx.drawImage(video, 0,0, canvas.width, canvas.height);
          const lumin = ZXing.BinaryBitmap.fromUint8Array(
            ZXing.RGBLuminanceSource.fromCanvas(canvas).matrix
          );
          const res = new ZXing.MultiFormatReader().decode(lumin);
          if(res) text = res.getText && res.getText();
        }

        if (text) {
  const inner = parseExamPayload(text);
  if (inner && inner.code) {
    const now = Math.floor(Date.now()/1000);
    if (inner.ts && inner.expSec && (now > inner.ts + inner.expSec)) {
      note.textContent = "QR je propadlý. Vygenerujte nový.";
    } else {
      stop();
      if ((inner.type || 'START').toUpperCase() === 'START') {
        ExamGuard.start(inner.code);
      } else {
        ExamGuard.finish();
      }
    }
    return;
  }
  // nepřečtený formát – pokračuj ve skenu
}

      }catch(_){ /* ignoruj */ }
      raf = requestAnimationFrame(tick);
    }
    raf = requestAnimationFrame(tick);

    stopCb = ()=>{
      cancelAnimationFrame(raf);
      if(stream){ stream.getTracks().forEach(t=>t.stop()); }
      overlay.style.display='none';
      running=false;
    };
  }

  function stop(){ if(stopCb) stopCb(); }

  return { start, stop };
})();

function startExamScan(){ QR.start('START'); }
function endExamScan(){   QR.start('END'); }
</script>

</body>
</html>







