<!doctype html>
<html lang="cs">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<link rel="manifest" href="./manifest.webmanifest?v=2025-09-41">
<meta name="apple-mobile-web-app-title" content="Bernio">
<title>Bernio</title>
<style>
  :root{
    --case:#203347; --lcd:#e9f0da; --lcd-text:#112016;
    --num:#d2d6dd; --num-text:#17202a;
    --fn:#2a3b4f;  --fn-text:#f7fbff;
    --pink:#f0a9ba; --pink2:#f4c5d0; --oval:#e8edf3; --shift:#ffd447; --alpha:#ff6b6b;
    --gap:10px; --r:18px; --shadow:0 2px 0 rgba(0,0,0,.35);
  }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;overflow:hidden}
  body{
    background:#0f1722;display:grid;place-items:center;
    padding:env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left);
    color:#fff; overscroll-behavior:contain;
  }
  .menu-top{ font-size: clamp(18px,4.2vw,22px); letter-spacing:.04em }
  .menu-bot{ font-size: clamp(16px,3.8vw,20px); font-weight:700 }
  .menu-grid{ display:flex; justify-content:space-between; padding:0 6px }
  .menu-grid span{ min-width: 30%; text-align:center }
/* MODE – horní řádek: tři nápisy vlevo/na střed/vpravo, bez změny výšky */
/* Horní MODE řádek – přesná L|C|R mřížka, velké jako zadávací text */
/* Horní MODE řádek – Deg | Rad | Gra (nebo ExS | ExE | Tea) vlevo/střed/vpravo */
.modebar{
  display:grid;
  grid-template-columns:1fr 1fr 1fr;
  align-items:center;
  width:100%;
  margin:0; padding:0;
}
.modebar .label{
  font-size:clamp(24px,6.2vw,33px); /* stejná jako zadávání */
  line-height:1.15;
  margin:0; padding:0;
}
.modebar .label:nth-child(1){ justify-self:start; }
.modebar .label:nth-child(2){ justify-self:center; }
.modebar .label:nth-child(3){ justify-self:end; }

/* Spodní MODE řádek – 1 | 2 | 3 vlevo/střed/vpravo; velikost jako výsledky (.res) */
.numrow{
  display:grid;
  grid-template-columns:1fr 1fr 1fr;
  align-items:center;
  width:100%;
  margin:0; padding:0;
  text-align:initial;     /* zruší pravé zarovnání .res pro tento obsah */
  font-size:inherit;      /* zdědí clamp z .res → stejná velikost jako výsledky */
}
.numrow span:nth-child(1){ justify-self:start; }
.numrow span:nth-child(2){ justify-self:center; }
.numrow span:nth-child(3){ justify-self:end; }
/* === MODE speciální layout pro spodní řádek s čísly === */
.res.mode{
  display:block;       /* v MODE nechceme flex-justify vpravo */
  text-align:initial;
  margin-left:0;
  min-width:100%;
  height:1.34em;       /* stejná FIXNÍ výška jako běžný výsledek */
  overflow:hidden;
}

.res.mode .numrow{
  display:grid;
  grid-template-columns: 1fr 1fr 1fr;
  align-items:center;
  width:100%;
  height:100%;         /* vyplň celý řádek */
}

.res.mode .numrow span:nth-child(1){ justify-self:start; }
.res.mode .numrow span:nth-child(2){ justify-self:center; }
.res.mode .numrow span:nth-child(3){ justify-self:end; }

  .calc{
    width:min(480px,100vw);
    height:auto;
    background:linear-gradient(#203347,#1a2c3d);
    border-radius:28px; padding:18px 14px 20px;
    box-shadow:0 24px 50px rgba(0,0,0,.55), inset 0 6px 0 rgba(255,255,255,.06);
    display:grid; grid-template-rows:auto auto; gap:12px;
    transform-origin: top center;
  }
  /* === TEST MODE UI === */
body.exam-on .calc{
  background: linear-gradient(var(--exam-c1, #ffe8f2), var(--exam-c2, #ffdbe8));
}

.display{
  background:var(--lcd); color:var(--lcd-text); border-radius:10px;
  padding:12px 14px; box-shadow:inset 0 3px 4px rgba(0,0,0,.25);
  font-family:ui-monospace,Menlo,Consolas,monospace;
  display:grid; grid-template-rows:auto auto; gap:0px; /* menší mezera */
  position:relative;
}
#exprWrap{
  font-size:clamp(26px,7vw,36px);  /* o kousek větší než dřív */
  line-height:1.28;
  min-height:1.46em;
  white-space:nowrap;
  overflow:hidden;
  position:relative;
}

  #expr{display:block; width:100%; white-space:nowrap; padding-right:8px;}

  .line2{display:flex; align-items:center; gap:8px; min-height:1.34em}

  .badges{
    position:absolute; top:4px; left:8px; right:8px;
    display:flex; gap:8px; flex-wrap:wrap; pointer-events:none;
  }
  .badge{
    background:transparent; border:none; color:#1b2b3b;
    border-radius:0; padding:0; font-size:.8em; line-height:1; user-select:none;
  }
  .badge.auto{display:none}
  .badge.auto.on{display:inline-flex}
  .badge.always{display:inline-flex}

.res{
  display:flex;                   /* aby sup/exp nevytahoval řádek */
  align-items:center;
  justify-content:flex-end;       /* výsledek vpravo (mimo MODE) */
  margin-left:auto;
  font-size:clamp(26px,7.2vw,36px);
  line-height:1.2;
  font-weight:700;
  min-width:40%;
  height:1.34em;                  /* FIXNÍ výška řádku výsledku */
  overflow:hidden;                /* nic nevyleze ven */
}



  .res .sci .times, .res .sci .ten{ font-size:.8em; }
  .res .sci sup.exp{ font-size:.5em; vertical-align:super; }

  .boards{display:grid;grid-template-rows:auto auto;gap:12px}
  .topgrid{display:grid;grid-template-columns:repeat(6,1fr);gap:var(--gap);grid-auto-rows:minmax(46px,auto);} 
  .botgrid{display:grid;grid-template-columns:repeat(5,1fr);gap:var(--gap);grid-auto-rows:minmax(64px,auto);} 

  .oval{background:var(--oval);color:#263445;border-radius:18px;padding:.6em .2em;text-align:center;font-weight:700;box-shadow:var(--shadow);touch-action:manipulation;-webkit-tap-highlight-color:transparent;cursor:pointer}
  #btnSHIFT{color:#b08c00} #btnALPHA{color:var(--alpha)} #btnFS{font-weight:800}
  .replay{background:#bfcbd9;color:#3b4b5c;border-radius:999px;font-size:20px}
  .span2{grid-row:span 2}

  .key{position:relative;border:none;border-radius:var(--r);padding:1.05em .3em .8em;text-align:center;box-shadow:var(--shadow);font-size:clamp(15px,3.2vw,19px);user-select:none;touch-action:manipulation;-webkit-tap-highlight-color:transparent;cursor:pointer}
  .key:active{transform:translateY(1px)}
  .num{background:var(--num);color:var(--num-text)} .fn{background:var(--fn);color:var(--fn-text)}
  .pink{background:var(--pink);color:#3b1c26} .pink.soft{background:var(--pink2)}
  .legend{position:absolute;top:6px;left:8px;font-size:.72em;color:#b08c00;opacity:.9;pointer-events:none}
  .main{display:block}
  .botgrid .key{padding:.85em .25em .6em;font-size:clamp(22px,7.2vw,34px)}
  .root{position:relative;display:inline-block;padding-left:.05em}
  .root .rad{display:inline-block;padding-left:.2em;margin-left:.05em;border-top:2px solid currentColor;line-height:1}
  .root small{font-size:.7em;vertical-align:super;margin-right:.05em}
  .root.small .rad{border-top-width:1.6px}
  .caret{display:inline-block;width:.7ch;text-align:center;animation:blink 1s step-end infinite;font-weight:700}
  @keyframes blink{50%{opacity:0}} sup{font-size:.7em}
 

</style>
</head>
<body>
<div class="calc" id="calc">
  <!-- DISPLEJ -->
  <div class="display">
    <div id="exprWrap"><div id="expr"></div></div>
    <div class="line2">
      <div class="badges">
        <span class="badge auto" id="bShift">SHIFT</span>
        <span class="badge auto" id="bHyp">HYP</span>
        <span class="badge always" id="bDRG">DEG</span>
        <span class="badge auto" id="bDMS">DMS</span>
        <span class="badge auto" id="bENG">ENG</span>
        <span class="badge auto" id="bMem">M</span>
        <span class="badge auto" id="bExamTimer"></span>
        <span class="badge auto" id="bExamCode" style="margin-left:auto"></span>
      </div>
      <span class="res" id="res"></span>
    </div>
  </div>

  <!-- HORNÍ 6×5 -->
  <div class="boards">
    <div class="topgrid">
      <button class="oval" id="btnSHIFT">SHIFT</button>
      <button class="oval" id="btnQR">QR</button>
      <button class="oval replay span2" id="btnLeft">◀</button>
      <button class="oval replay span2" id="btnRight">▶</button>
      <button class="oval" id="btnMODE"><span class="main">MODE</span></button>
      <button class="oval" id="btnFS">⛶</button>

      <button class="key fn" id="btnInv"><span class="legend">x!</span><span class="main">x⁻¹</span></button>
      <button class="key fn" id="btnComb"><span class="legend">nPr</span><span class="main">nCr</span></button>
      <button class="key fn" id="btnPolRec"><span class="legend">Rec(</span><span class="main">Pol(</span></button>
      <button class="key fn" id="btnPow3"><span class="legend"><span class="root small"><small>3</small>√<span class="rad">x</span></span></span><span class="main">x³</span></button>

      <button class="key fn" id="btnFracKey"><span class="legend">d/c</span><span class="main">a b/c</span></button>
      <button class="key fn" id="btnSqrt"><span class="main"><span class="root">√<span class="rad">x</span></span></span></button>
      <button class="key fn" id="btnPow2"><span class="main">x²</span></button>
      <button class="key fn" id="btnPow"><span class="legend"><span class="root small"><small>y</small>√<span class="rad">x</span></span></span><span class="main">^</span></button>
      <button class="key fn" data-fn="log"><span class="legend">10ˣ</span><span class="main">log</span></button>
      <button class="key fn" data-fn="ln"><span class="legend">eˣ</span><span class="main">ln</span></button>

      <button class="key fn" id="btnNeg"><span class="main">(−)</span></button>
      <button class="key fn" id="btnDMSsym"><span class="main">° ′ ″</span></button>
      <button class="key fn" id="btnHYP"><span class="main">hyp</span></button>
      <button class="key fn" data-trig="sin"><span class="legend">sin⁻¹</span><span class="main">sin</span></button>
      <button class="key fn" data-trig="cos"><span class="legend">cos⁻¹</span><span class="main">cos</span></button>
      <button class="key fn" data-trig="tan"><span class="legend">tan⁻¹</span><span class="main">tan</span></button>

      <button class="key fn" id="btnRCLSTO"><span class="legend">STO</span><span class="main">RCL</span></button>
      <button class="key fn" id="btnENG"><span class="main">ENG</span></button>
      <button class="key fn" data-ins="(" id="btnParL"><span class="main">(</span></button>
      <button class="key fn" data-ins=")" id="btnParR"><span class="main">)</span></button>
      <button class="key fn" data-ins="," id="btnComma"><span class="main">,</span></button>
      <button class="key fn" id="btnMpm"><span class="legend">M−</span><span class="main">M+</span></button>
    </div>

    <!-- DOLNÍ 5×4 -->
    <div class="botgrid">
      <button class="key num" data-ins="7"><span class="main">7</span></button>
      <button class="key num" data-ins="8"><span class="main">8</span></button>
      <button class="key num" data-ins="9"><span class="main">9</span></button>
      <button class="key pink" data-act="del"><span class="legend">INS</span><span class="main">DEL</span></button>
      <button class="key pink soft" data-act="ac"><span class="main">AC</span></button>

      <button class="key num" data-ins="4"><span class="main">4</span></button>
      <button class="key num" data-ins="5"><span class="main">5</span></button>
      <button class="key num" data-ins="6"><span class="main">6</span></button>
      <button class="key num" data-ins="×"><span class="main">×</span></button>
      <button class="key num" data-ins="÷"><span class="main">÷</span></button>

      <button class="key num" data-ins="1"><span class="main">1</span></button>
      <button class="key num" data-ins="2"><span class="main">2</span></button>
      <button class="key num" data-ins="3"><span class="main">3</span></button>
      <button class="key num" data-ins="+"><span class="main">+</span></button>
      <button class="key num" data-ins="−"><span class="main">−</span></button>

      <button class="key num" id="btn0"><span class="legend">Rnd</span><span class="main">0</span></button>
      <button class="key num" id="btnDot"><span class="legend">Ran#</span><span class="main">.</span></button>
      <button class="key num" id="btnEXP"><span class="legend">π</span><span class="main">EXP</span></button>
      <button class="key num" id="btnAns"><span class="legend">DRG▶</span><span class="main">Ans</span></button>
      <button class="key num" id="btnEq"><span class="legend">%</span><span class="main">=</span></button>
    </div>
  </div>
</div>

<!-- RESET SW/Cache helper -->
<script>
(async () => {
  const p = new URL(location.href).searchParams;
  if (p.get('reset') === '1' && 'serviceWorker' in navigator) {
    try {
      const regs = await navigator.serviceWorker.getRegistrations();
      for (const r of regs) await r.unregister();
      if ('caches' in window) {
        const keys = await caches.keys();
        for (const k of keys) await caches.delete(k);
      }
    } catch {}
    location.replace(location.pathname);
  }
})();
</script>
<script>
/* ===== drobné utily ===== */
const qs=s=>document.querySelector(s);
function onPD(el, fn){ if(!el) return; el.addEventListener('pointerdown', fn, {passive:true}); }
function onPDAll(sel,fn){ document.querySelectorAll(sel).forEach(el=>onPD(el,()=>fn(el))); }
/* === autopřizpůsobení výšce v ne-fullscreenu === */
const calcBox = document.getElementById('calc');
function isFS(){ const d=document; return !!(d.fullscreenElement||d.webkitFullscreenElement); }

function fitToViewport(){
  if(isFS()){
    calcBox.style.transform='scale(1)';
    calcBox.style.marginTop='';
    return;
  }
  const vv = window.visualViewport ? window.visualViewport.height : window.innerHeight;
  const cs = getComputedStyle(document.body);
  const avail = vv - parseFloat(cs.paddingTop||0) - parseFloat(cs.paddingBottom||0);

  calcBox.style.transform='scale(1)';
  calcBox.style.marginTop='';
  const need = calcBox.getBoundingClientRect().height;

  const s = Math.min(1, avail / need);
  if(s < 1){
    calcBox.style.transform = `scale(${s})`;
    const extra = (avail - need*s)/2;
    calcBox.style.marginTop = `${Math.max(0, extra)}px`;
  }
}
window.addEventListener('resize', fitToViewport);
window.addEventListener('orientationchange', fitToViewport);

/* ===== stav ===== */
const exprEl=qs('#expr'), resEl=qs('#res');
const bShift=qs('#bShift'), bHyp=qs('#bHyp'), bDRG=qs('#bDRG'), bENG=qs('#bENG'), bDMS=qs('#bDMS'), bMem=qs('#bMem');
const calcEl = document.getElementById('calc');
const TEACHER_URL = "https://berniocal.github.io/teacher.html"; // jediný zdroj pravdy
const API_BASE = "https://examqr.jendabernard.workers.dev";
function API(p){ return String(API_BASE).replace(/\/+$/,'') + '/' + String(p).replace(/^\/+/, ''); }

function renderModeMenu(){
  function setMenu(labels){
    exprEl.innerHTML =
      '<div class="modebar">' +
        `<span class="label">${labels[0]}</span>` +
        `<span class="label">${labels[1]}</span>` +
        `<span class="label">${labels[2]}</span>` +
      '</div>';
    resEl.classList.add('mode');
    resEl.innerHTML = '<div class="numrow"><span>1</span><span>2</span><span>3</span></div>';

    // udělej horní 1/2/3 klikací
    const row = resEl.querySelector('.numrow');
    if (row){
      Array.from(row.children).forEach((el, i)=>{
        el.style.cursor = 'pointer';
        el.addEventListener('pointerdown', (ev)=>{
          ev.preventDefault();
          handleMenuChoice(String(i+1));   // 1 → start, 2 → end, 3 → teacher
        }, { passive:false });
      });
    }
    return true;
  }
  if (state.modeStage === 1) return setMenu(['Deg','Rad','Gra']);
  if (state.modeStage === 2) return setMenu(['ExS','ExE','Tea']);
  resEl.classList.remove('mode');
  return false;
}
 
// akce menu čísel 1/2/3
function handleMenuChoice(digit){
  if(state.modeStage===1){
    if(digit==='1') state.drg='DEG';
    else if(digit==='2') state.drg='RAD';
    else if(digit==='3') state.drg='GRAD';
    state.modeStage=0; state.resultShown=false; state.resultStr='';
    render();
    return true;
  }
  if(state.modeStage===2){
    if(digit==='1'){ startExamScan(); }
    else if(digit==='2'){ endExamScan(); }
    else if(digit==='3'){ openTeacher(); }
    state.modeStage=0; render();
    return true;
  }
  return false;
}




// Hoist-safe definice (použitá v menu)
function openTeacher(){
  try{ window.open(TEACHER_URL, '_blank', 'noopener'); }catch(_){}
}
</script>
  <script>
/* ===================== Exam minimal + notifyEvent + hidden video ===================== */
// Jednoduché hlášení událostí pro teacher (žádné heartbeat)
async function notifyEvent(type, extra = {}) {
  try {
    await fetch(API('api/event'), {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        code: state.examCode || '',
        pid: Exam.state.pid || null,
        type,                          // 'hidden' | 'offline' | (volitelně 'online')
        ...extra
      })
    });
  } catch (_) {}
}

// iOS/SAFARI: skryté (1×1) video pro udržení displeje/medií „v chodu“
let __hiddenVideo = null;
function startHiddenVideoTrick() {
  if (__hiddenVideo) return;
  const v = document.createElement('video');
  v.muted = true;
  v.loop = true;
  v.playsInline = true;
  v.style.cssText = "position:absolute;width:1px;height:1px;opacity:0;pointer-events:none";
  v.src = "data:video/mp4;base64,AAAA";
  document.body.appendChild(v);
  const tryPlay = () => { v.play().catch(()=>{}); document.removeEventListener('pointerdown', tryPlay); };
  document.addEventListener('pointerdown', tryPlay, { passive: true });
  __hiddenVideo = v;
}
function stopHiddenVideoTrick() {
  if (!__hiddenVideo) return;
  try { __hiddenVideo.pause(); } catch {}
  try { __hiddenVideo.remove(); } catch {}
  __hiddenVideo = null;
}

// Minimalistický Exam (bez senzorů, bez zvuků, jen UI + eventy)
const Exam = (() => {
  const S = { active:false, pid:null, startAt:0, timerId:0 };

  function setUIOn(code){
    state.examActive = true;
    state.examCode   = code;
    updateExamUI();
    startExamColorCycleDeterministic(code);
    const tEl = document.getElementById('bExamTimer');
    const tick = () => {
      if (!S.startAt || !tEl) return;
      const mins = Math.floor((Date.now() - S.startAt)/60000);
      tEl.textContent = `${mins} min`;
      tEl.classList.add('on');
    };
    if (S.timerId) clearInterval(S.timerId);
    tick();
    S.timerId = setInterval(tick, 6000);
    startHiddenVideoTrick();
  }
  function setUIOff(){
    if (S.timerId) { clearInterval(S.timerId); S.timerId = 0; }
    const tEl = document.getElementById('bExamTimer');
    if (tEl) { tEl.textContent=''; tEl.classList.remove('on'); }
    state.examActive = false;
    state.examCode   = '';
    updateExamUI();
    stopExamColorCycle();
    stopHiddenVideoTrick();
  }

  function onVisibility(){ if (S.active && document.hidden) notifyEvent('hidden'); }
  function onOffline(){ if (S.active && !navigator.onLine) notifyEvent('offline'); }
  function onOnline(){ /* případně: if (S.active) notifyEvent('online'); */ }

  async function start(code){
    if (S.active) return;
    if (!navigator.onLine){ alert('Pro start musíš být online.'); return; }
    let ident = (window.prompt && window.prompt('Zadej svůj IDENTIFIKÁTOR:')) || '';
    ident = String(ident||'').trim();
    if (!ident){ alert('Bez identifikátoru nelze pokračovat.'); return; }
    try{
      const resp = await fetch(API('api/join'), {
        method:'POST',
        headers:{ 'Content-Type':'application/json' },
        body: JSON.stringify({ code: String(code||'').toUpperCase().slice(0,3), ident })
      });
      const text = await resp.text();
      const data = text ? JSON.parse(text) : null;
      if (!resp.ok) throw new Error((data && data.error) || `${resp.status} ${resp.statusText}`);
      if (!data || !data.pid) throw new Error('Bad response from /api/join');
      S.pid = data.pid;
    }catch(e){
      alert('Nelze se připojit k testu.\n' + String(e.message||e));
      return;
    }
    S.active = true;
    S.startAt = Date.now();
    const norm = String(code||'').toUpperCase().slice(0,3);
    setUIOn(norm);
    document.addEventListener('visibilitychange', onVisibility);
    window.addEventListener('offline', onOffline);
    window.addEventListener('online', onOnline);
    state.resultShown = true;
    state.resultStr = 'Test mód aktivní.';
    render();
  }
  function finish(){
    if (!S.active) return;
    document.removeEventListener('visibilitychange', onVisibility);
    window.removeEventListener('offline', onOffline);
    window.removeEventListener('online', onOnline);
    S.active = false;
    S.pid = null;
    S.startAt = 0;
    setUIOff();
    state.resultShown = true;
    state.resultStr = 'Zkouška ukončena.';
    render();
  }
  return { start, finish, get state(){ return S; } };
})();
</script>


<script>
let state={ raw:'', cursor:0, ans:0, drg:'DEG', shift:false, hyp:false, eng:false,
            dmsDisplay:false, frac:false, fracMixed:true, memory:0, memOn:false,
            lastRes:null, resultShown:false, resultStr:'', editAfterResult:false,
            modeStage:0, repeat:null, examActive:false, examCode:'' };

/* ===== pretty + caret, auto scroll kurzoru ===== */
function prettySegments(raw){
  const segs=[]; let i=0; const push=(h,l)=>segs.push({html:h,len:l});
  while(i<raw.length){
    if(raw.startsWith('pow10(',i)){ push('10^(',6); i+=6; continue; }
    if(raw.startsWith('exp(',i)){   push('e^(',4);   i+=4; continue; }
    if(raw.startsWith('asin(',i)){  push('sin<sup>−1</sup>(',5); i+=5; continue; }
    if(raw.startsWith('acos(',i)){  push('cos<sup>−1</sup>(',5); i+=5; continue; }
    if(raw.startsWith('atan(',i)){  push('tan<sup>−1</sup>(',5); i+=5; continue; }
    if(raw.startsWith('sqrt(',i)){  push('√(',5); i+=5; continue; }
    if(raw.startsWith('cbrt(',i)){  push('∛(',5); i+=5; continue; }
    if(raw.startsWith('root(',i)){
      let j=i+5,y=''; while(j<raw.length&&/[0-9.]/.test(raw[j])) y+=raw[j++];
      if(raw[j]===','){ push(y+'√(', j-i+1); i=j+1; continue; }
    }
    if(raw[i]==='^' && raw[i+1]==='('){
      let j=i+2; while(j<raw.length && raw[j]!==')') j++;
      if(j<raw.length){ const expo=raw.slice(i+2,j).replace(/-/g,'−'); push('<sup>'+expo+'</sup>', j-i+1); i=j+1; continue; }
    }
    const ch=raw[i]; const pretty = ch==='*'?'×': ch==='/'?'÷': ch==='-'?'−': ch;
    push(pretty,1); i++;
  }
  return segs;
}
function scrollToCaret(){
  const wrap=document.getElementById('exprWrap');
  const c=wrap.querySelector('.caret');
  if(!c) return;
  const wr=wrap.getBoundingClientRect();
  const cr=c.getBoundingClientRect();
  const pad=8;
  if(cr.right>wr.right-pad) wrap.scrollLeft += (cr.right - wr.right + pad);
  else if(cr.left<wr.left+pad) wrap.scrollLeft -= (wr.left - cr.left + pad);
}
function render(){
  bShift.classList.toggle('on',state.shift);
  bHyp.classList.toggle('on',state.hyp);
  bENG.classList.toggle('on',state.eng);
  bDMS.classList.toggle('on',state.dmsDisplay);
  bMem.classList.toggle('on',state.memOn);
  bDRG.textContent=state.drg;
  calcEl.classList.toggle('shift-on', state.shift);

  if(renderModeMenu()){
    return;
  }
  const segs=prettySegments(state.raw);
  let out='', count=0, placed=false;
  for(const s of segs){
    if(!placed && state.cursor<=count){ out+='<span class="caret">_</span>'; placed=true; }
    out+=s.html; count+=s.len;
  }
  if(!placed) out+='<span class="caret">_</span>';
  exprEl.innerHTML = out;

  resEl.innerHTML = state.resultShown ? state.resultStr : '';

  scrollToCaret();
}
function updateExamUI(){
  document.body.classList.toggle('exam-on', !!state.examActive);

  const badgeCode = document.getElementById('bExamCode');
  const badgeTimer = document.getElementById('bExamTimer');

  // kód z QR
  if (badgeCode) {
    if (state.examActive && state.examCode){
      badgeCode.textContent = state.examCode.toUpperCase();
      badgeCode.classList.add('on');
    } else {
      badgeCode.textContent = '';
      badgeCode.classList.remove('on');
    }
  }

  // timer vlevo – jen v exam-mode
  if (badgeTimer) {
    if (state.examActive){
      badgeTimer.classList.add('on');
      // barva odlišená od kódu (klidně uprav podle vkusu)
      badgeTimer.style.color = '#0aa';
      badgeTimer.style.fontWeight = '700';
    } else {
      badgeTimer.textContent = '';
      badgeTimer.classList.remove('on');
    }
  }
}

  window.updateExamUI = updateExamUI;
// === Exam background tween (5 minut plynule) ===
let examRAF = 0;

function hashCode(str){
  let h = 0; for (let i=0;i<str.length;i++) h = (h*31 + str.charCodeAt(i)) >>> 0;
  return h >>> 0;
}
function seededRandom(seed){
  let x = (seed % 2147483647) || 1;
  return () => (x = (x * 48271) % 2147483647) / 2147483647;
}
function hsl(h, s, l){ return {h, s, l}; } // 0-360, 0-1, 0-1

function hslToRgbArray(h, s, l){
  // očekává h v [0..360), s,l v [0..1]; vrací [R,G,B] 0..255
  const c = (1 - Math.abs(2*l - 1)) * s;
  const hp = (h % 360) / 60;
  const x = c * (1 - Math.abs((hp % 2) - 1));
  let r=0,g=0,b=0;
  if (0<=hp&&hp<1){ r=c; g=x; b=0; }
  else if (1<=hp&&hp<2){ r=x; g=c; b=0; }
  else if (2<=hp&&hp<3){ r=0; g=c; b=x; }
  else if (3<=hp&&hp<4){ r=0; g=x; b=c; }
  else if (4<=hp&&hp<5){ r=x; g=0; b=c; }
  else { r=c; g=0; b=x; }
  const m = l - c/2;
  const R = Math.round((r+m)*255);
  const G = Math.round((g+m)*255);
  const B = Math.round((b+m)*255);
  return [R, G, B];
}
function rgbToCss(rgb){ const [R,G,B] = rgb; return `rgb(${R}, ${G}, ${B})`; }

function lerp(a, b, t){ return a + (b - a) * t; }
function lerpHsl(a, b, t){
  // plynule i přes 360/0 (zkrácenou cestou)
  let dh = ((b.h - a.h + 540) % 360) - 180;
  return hsl(
    (a.h + dh*t + 360) % 360,
    lerp(a.s, b.s, t),
    lerp(a.l, b.l, t)
  );
}

let tween = null;
/*
  tween = {
    rand,               // RNG pro deterministické další cíle
    start1, start2,     // HSL start gradientu
    end1, end2,         // HSL cíl gradientu
    t0,                 // start timestamp (ms)
    dur: 300000         // 5 minut
  }
*/
// === Forbidden / similar-to-base-color filter ===
const BASE_BG_HEX = ['#203347', '#1a2c3d']; // běžné pozadí kalkulačky

function hexToRgb(hex){
  const h = hex.replace('#','');
  return [parseInt(h.slice(0,2),16), parseInt(h.slice(2,4),16), parseInt(h.slice(4,6),16)];
}
function srgbToLinear(v){ // v ∈ [0..1]
  return (v <= 0.04045) ? (v/12.92) : Math.pow((v+0.055)/1.055, 2.4);
}
function rgbDistLinear(a, b){ // eukleid v lineárním RGB, citlivější na tmavé
  const al = a.map(v => srgbToLinear(v/255));
  const bl = b.map(v => srgbToLinear(v/255));
  const dx = al[0]-bl[0], dy = al[1]-bl[1], dz = al[2]-bl[2];
  return Math.sqrt(dx*dx + dy*dy + dz*dz);
}
const FORBIDDEN_RGB = BASE_BG_HEX.map(hexToRgb);
// práh podobnosti – 0.18 je docela přísný; zvětši → víc vyhazuje
const FORBIDDEN_DIST = 0.18;

function isNearForbidden(rgb){
  return FORBIDDEN_RGB.some(base => rgbDistLinear(rgb, base) < FORBIDDEN_DIST);
}

function randomPastel(rand){
  // původně sis bral h, s, l → nechávám styl podobný
  // Pastely: vyšší s, vyšší l (ale ne úplně křiklavé)
  let tries = 0;
  while(true){
    const h = rand()*360;
    const s = 0.45 + rand()*0.35;   // 45–80 %
    const l = 0.62 + rand()*0.18;   // 62–80 %
    const rgb = hslToRgbArray(h, s, l);  // [R,G,B]



    // vyřaď barvy podobné běžnému pozadí kalkulačky
    if (!isNearForbidden(rgb)) {
      return { h, s, l, rgb };
    }
    if (++tries > 40){
      // nouzový únik – když náhodou padáme jen do zakázané zóny
      return { h, s, l, rgb };
    }
  }
}

function hueDiff(a,b){
 const d = Math.abs(a.h - b.h) % 360;
return d > 180 ? 360 - d : d;
}
function pickNextTargets(rand){
const c1 = randomPastel(rand);
let c2 = randomPastel(rand);
let tries = 0;
 // udrž aspoň ~50° rozestup v hue, ať nejsou obě barvy moc podobné
 while (hueDiff(c1, c2) < 50 && tries++ < 20) c2 = randomPastel(rand);
 return { c1, c2 };
} 
function applyGradient(c1, c2){
  const rgb1 = hslToRgbArray(c1.h, c1.s, c1.l);
  const rgb2 = hslToRgbArray(c2.h, c2.s, c2.l);
  document.documentElement.style.setProperty('--exam-c1', rgbToCss(rgb1));
document.documentElement.style.setProperty('--exam-c2', rgbToCss(rgb2));


}


function stepExamTween(now){
  if(!tween) return;
  const {start1, start2, end1, end2, t0, dur, rand} = tween;
  let p = (now - t0) / dur;
  if (p >= 1){
    // hotovo – nastav cíl, vygeneruj nový cíl, reset času
    applyGradient(end1, end2);
    const next = pickNextTargets(rand);
    tween.start1 = end1;
    tween.start2 = end2;
    tween.end1 = next.c1;
    tween.end2 = next.c2;
    tween.t0 = now;
     p = 0;
    // nová (náhodná) délka příštího přechodu
    tween.dur = 45000 + Math.floor(rand()*45000);
  }
  const cur1 = lerpHsl(tween.start1, tween.end1, Math.min(Math.max(p,0),1));
  const cur2 = lerpHsl(tween.start2, tween.end2, Math.min(Math.max(p,0),1));
  applyGradient(cur1, cur2);
  examRAF = requestAnimationFrame(stepExamTween);
}

function startExamColorCycleDeterministic(code){
  stopExamColorCycle(); // jistota čistého startu

  const seed = hashCode(String(code||'').toUpperCase());
  const rand = seededRandom(seed);

 // Počáteční barvy: hned náhodné pastely (žádná fixní růžová)
 const first  = pickNextTargets(rand);
 const start1 = first.c1;
 const start2 = first.c2;
 const target = pickNextTargets(rand);
  tween = {
    rand,
    start1, start2,
    end1: target.c1,
    end2: target.c2,
    t0: performance.now(),
   // rychlejší a variabilní: 45–90 s
   dur: 45000 + Math.floor(rand()*45000)
  };

  // nastav okamžitě start, ať UI hned sedí
  applyGradient(start1, start2);

  examRAF = requestAnimationFrame(stepExamTween);
}

function stopExamColorCycle(){
  if (examRAF){ cancelAnimationFrame(examRAF); examRAF = 0; }
  tween = null;
  // vrátit default (necháš klidně růžovou nebo smaž proměnné)
  document.documentElement.style.removeProperty('--exam-c1');
  document.documentElement.style.removeProperty('--exam-c2');
}

function clearForNewEntry(){ if(state.resultShown && !state.editAfterResult){ state.resultShown=false; state.resultStr=''; state.raw=''; state.cursor=0; } }
function insRaw(txt){ clearForNewEntry(); state.raw=state.raw.slice(0,state.cursor)+txt+state.raw.slice(state.cursor); state.cursor+=txt.length; render(); }

/* SMART-DEL bloky */
function smartDeleteUnit(){
  const wrap=document.getElementById('exprWrap');
  if(state.cursor>0 && state.raw[state.cursor-1]==='('){
    let j=state.cursor-2;
    while(j>=0 && /[A-Za-z0-9_#]/.test(state.raw[j])) j--;
    const start=j+1;
    if(start<state.cursor-1){
      state.raw = state.raw.slice(0,start) + state.raw.slice(state.cursor);
      state.cursor = start;
      wrap.scrollLeft=Math.max(0,wrap.scrollLeft-20);
      return true;
    }
  }
  return false;
}
function smartDeleteRootComma(){
  if(!(state.cursor>0 && state.raw[state.cursor-1]===',')) return false;
  let p = state.cursor-2;
  while(p>=0 && /[0-9.+\-Ee]/.test(state.raw[p])) p--;
  if(p>=0 && state.raw[p]==='(' && p>=4 && state.raw.slice(p-4,p)==='root'){
    const y = state.raw.slice(p+1, state.cursor-1);
    state.raw = state.raw.slice(0, p-4) + y + state.raw.slice(state.cursor);
    state.cursor = (p-4) + y.length;
    return true;
  }
  return false;
}
// === FRACTION TOGGLE (d/c) v řádku zadávání ===
// najdi nejbližší zlomek (separátor "∟") obsahující kurzor:
//   A ∟ B ∟ C  … smíšený (A + B/C)
//   N ∟ D      … nepravý/pravoúhlý
function findFractionSpanAroundCursor(src, cursor){
  const re = /-?\d+(?:\.\d+)?\s*∟\s*\d+(?:\s*∟\s*\d+)?/g;
  let m, hit=null;
  while ((m = re.exec(src))){
    const s = m.index, e = s + m[0].length;
    if (s <= cursor && cursor <= e){ hit = { start:s, end:e, text:m[0] }; }
  }
  return hit;
}

// přehoď smíšený ↔ nepravý textově (bez závorek a operátorů)
function toggleFractionText(txt){
  // normalizace mezer kolem ∟
  const parts = txt.replace(/\s*∟\s*/g,' ∟ ').trim().split(/\s*∟\s*/);

  if (parts.length === 3){
    // A ∟ B ∟ C  -> (A*C + B) ∟ C
    const A = +parts[0], B = +parts[1], C = +parts[2];
    if (!isFinite(A)||!isFinite(B)||!isFinite(C)||C===0) return txt;
    const sign = A < 0 ? -1 : 1;     // smíšené číslo nese znamenko v A
    const N = sign*(Math.abs(A)*C + B);
    return `${N} ∟ ${C}`;
  }
  if (parts.length === 2){
    // N ∟ D  ->  W ∟ R ∟ D   (jen když |N| >= D a R>0)
    const N = +parts[0], D = +parts[1];
    if (!isFinite(N)||!isFinite(D)||D===0) return txt;
    const sign = N < 0 ? -1 : 1;
    const n = Math.abs(N);
    if (n < D) return txt;           // už je vlastník → neměň
    const W = Math.floor(n / D);
    const R = n % D;
    if (R === 0) return String(sign*W);  // přesně celé číslo
    const w = sign < 0 ? -W : W;         // znaménko přenes na celé
    return `${w} ∟ ${R} ∟ ${D}`;
  }
  return txt;
}

// proveď přepnutí u zlomku, který obsahuje kurzor; vrať true pokud proběhlo
function toggleFractionAtCursor(){
  const hit = findFractionSpanAroundCursor(state.raw, state.cursor);
  if (!hit) return false;
  const newTxt = toggleFractionText(hit.text);
  if (newTxt === hit.text) return false;
  state.raw = state.raw.slice(0, hit.start) + newTxt + state.raw.slice(hit.end);
  // posuň kurzor na konec upraveného zlomku
  state.cursor = hit.start + newTxt.length;
  return true;
}

function back(){
  if(smartDeleteRootComma()){ render(); return; }
  if(smartDeleteUnit()){ render(); return; }
  if(state.resultShown && !state.editAfterResult){
    state.resultShown=false; state.resultStr=''; render(); return;
  }
  if(state.cursor<=0){ render(); return; }
  state.raw = state.raw.slice(0,state.cursor-1)+state.raw.slice(state.cursor);
  state.cursor--; render();
}

function moveCursor(step){ if(state.resultShown) state.editAfterResult=true; state.cursor=Math.max(0,Math.min(state.raw.length,state.cursor+step)); render(); }
function ac(hard=false){ state.raw=''; state.cursor=0; if(hard){ state.ans=0; } state.resultShown=false; state.resultStr=''; state.lastRes=null; state.editAfterResult=false; document.getElementById('exprWrap').scrollLeft=0; render(); }

/* ovládací prvky */
onPD(qs('#btnSHIFT'), ()=>{
  if (state.modeStage > 0) { 
    state.modeStage = 0; 
    render(); 
    return; 
  }
  state.shift = !state.shift;
  render();
});

onPD(qs('#btnMODE'), ()=>{ 
  if(state.shift){ state.shift=false; state.ans=0; ac(true); return; }
  state.resultShown=false; state.resultStr='';
  state.modeStage = (state.modeStage===0) ? 1 : (state.modeStage===1 ? 2 : 0);
  render();
});

onPD(qs('#btnLeft'),  ()=> moveCursor(-1));
onPD(qs('#btnRight'), ()=> moveCursor(+1));

onPD(qs('#btnFS'), ()=>{ 
  const doc=document, el=doc.documentElement;
  const inFS=doc.fullscreenElement||doc.webkitFullscreenElement;
  const req=el.requestFullscreen||el.webkitRequestFullscreen;
  const exit=doc.exitFullscreen||doc.webkitExitFullscreen||(()=>Promise.resolve());
  if(inFS){ try{ exit.call(doc); }catch(e){} }
  else{
    if(req){ try{ const p=req.call(el); if(p&&p.catch)p.catch(()=>window.scrollTo(0,1)); }catch(e){ window.scrollTo(0,1); } }
    else { window.scrollTo(0,1); }
  }
  setTimeout(fitToViewport, 120);
});

/* funkční klávesy */
onPD(qs('#btnInv'), ()=>{
  if(state.resultShown && !state.editAfterResult){
    // Po "=", držíme výsledek zobrazený a stavíme na Ans
    state.editAfterResult = true;
    if(state.shift){
      state.shift = false;
      state.raw = 'Ans!';              // faktorál Ans
      state.cursor = state.raw.length;
      render();
    } else {
      state.raw = 'Ans^(-1)';          // převrácená hodnota Ans
      state.cursor = state.raw.length;
      render();
    }
    return;
  }
  // běžné chování při editaci výrazu
  clearForNewEntry();
  if(state.shift){
    state.shift=false;
    if(state.cursor>0 && /[0-9\)]/.test(state.raw[state.cursor-1])) insRaw('!');
    else insRaw('fact(');
  } else {
    insRaw('^(-1)');
  }
});


function insertCP(op){ if(state.resultShown && !state.editAfterResult) return; if(state.cursor===0 || !/[0-9]/.test(state.raw[state.cursor-1])) return; insRaw(op); }
onPD(qs('#btnComb'),()=>{ if(state.shift){ state.shift=false; insertCP('P'); } else insertCP('C'); });

onPD(qs('#btnPolRec'),()=>{ clearForNewEntry(); if(state.shift){ state.shift=false; insRaw('Rec(');} else insRaw('Pol('); });
onPD(qs('#btnPow3'),()=>{
  if(state.resultShown && !state.editAfterResult){
    state.editAfterResult = true;
    if(state.shift){
      state.shift=false;
      state.raw = 'cbrt(Ans)';        // ∛(Ans)
      state.cursor = state.raw.length;
      render();
    } else {
      state.raw = 'Ans^(3)';          // Ans^3
      state.cursor = state.raw.length;
      render();
    }
    return;
  }
  clearForNewEntry();
  if(state.shift){ state.shift=false; insRaw('cbrt(');} else insRaw('^(3)');
});

onPD(qs('#btnFracKey'), ()=>{
  // === Po "=": přepínání formátu výsledku (zůstává stejné chování) ===
  if (state.resultShown){
    if (state.shift){
      state.shift = false;
      state.frac = true;         // zapnout zlomkový výstup
      state.fracMixed = false;   // …a nepravý (d/c)
    } else {
      // cyklus: vyp → smíšený → vyp → smíšený …
      if (!state.frac){ state.frac = true; state.fracMixed = true; }
      else if (state.frac && state.fracMixed){ state.frac = false; }
      else { state.frac = true; state.fracMixed = true; }
    }
    updateResultView(); render();
    return;
  }

  // === V řádku zadávání: SHIFT + (a b/c) = d/c toggle pod kurzorem ===
  if (state.shift){
    state.shift = false;
    if (toggleFractionAtCursor()){ render(); return; }
    // když u kurzoru žádný zlomek není, nic nedělej
    render();
    return;
  }

  // běžné vložení separátoru "∟"
  clearForNewEntry();
  insRaw('∟');
});


onPD(qs('#btnSqrt'),()=>{ clearForNewEntry(); insRaw('sqrt('); });
onPD(qs('#btnPow2'),()=>{
  if(state.resultShown && !state.editAfterResult){
    state.editAfterResult = true;
    state.raw = 'Ans^(2)';            // Ans^2
    state.cursor = state.raw.length;
    render();
    return;
  }
  clearForNewEntry();
  insRaw('^(2)');
});


onPD(qs('#btnPow'), ()=>{ 
  if(state.shift){
    state.shift=false;
    let i=state.cursor-1,start=i+1; while(i>=0&&/[0-9.]/.test(state.raw[i])) i--; start=i+1;
    const y=state.raw.slice(start,state.cursor);
    if(y){ state.raw=state.raw.slice(0,start)+state.raw.slice(state.cursor); state.cursor=start; insRaw('root('+y+','); }
    else  insRaw('root(');
  }else{ opAfterResult('^'); }
});
onPD(qs('#btnHYP'), ()=>{ state.hyp=!state.hyp; render(); });
onPD(qs('#btnNeg'), ()=> insRaw('−'));

onPD(qs('#btnDMSsym'),()=>{
  // Pokud je zobrazen výsledek a nezačali jsme editovat, přepínej DMS <-> desetinný
  if(state.resultShown && !state.editAfterResult){
    state.dmsDisplay = !state.dmsDisplay;
    updateResultView();
    return;
  }

  // Rozsah pouze v aktuálním "členu" za posledním operátorem nebo levou závorkou
  const ops = ['+', '−', '×', '÷', ',', '('];
  const beforeAll = state.raw.slice(0, state.cursor);
  let segStart = 0;
  for (const op of ops) {
    const idx = beforeAll.lastIndexOf(op);
    if (idx >= segStart) segStart = idx + 1;
  }
  const scope = beforeAll.slice(segStart);

  // SHIFT může vynutit konkrétní symboly (zpětná kompatibilita)
  if(state.shift && state.hyp){ state.shift=false; insRaw('″'); return; }
  if(state.shift){ state.shift=false; insRaw('′'); return; }

  const lastDeg = scope.lastIndexOf('°');
  const lastMin = scope.lastIndexOf('′');
  const lastSec = scope.lastIndexOf('″');

  // 1) v aktuálním členu ještě nebyl "°" → vlož "° "
  if(lastDeg === -1){
    insRaw('° ');
    return;
  }
  // 2) máme "°", ale ne "′" → vlož "′ "
  if(lastMin < lastDeg){
    insRaw('′ ');
    return;
  }
  // 3) máme i "′", ale ne "″" → vlož "″"
  if(lastSec < lastMin){
    insRaw('″');
    return;
  }
  // 4) kompletní trojice je hotová → začni novou DMS sekvenci v tomto členu
  insRaw(' ° ');
});


onPD(qs('#btnRCLSTO'),()=>{ if(state.shift){ state.shift=false; state.memory= +state.ans || 0; state.memOn=state.memory!==0; render(); } else insRaw(String(state.memory)); });
onPD(qs('#btnENG'),()=>{ state.eng=!state.eng; if(state.resultShown) updateResultView(); render(); });
onPD(qs('#btnMpm'),()=>{ if(state.shift){ state.shift=false; state.memory -= (+state.ans||0); } else { state.memory += (+state.ans||0); } state.memOn=state.memory!==0; render(); });

onPDAll('[data-fn]', el=>{ clearForNewEntry(); const f=el.dataset.fn; if(f==='log'){ if(state.shift){ state.shift=false; insRaw('pow10('); } else insRaw('log('); } if(f==='ln'){ if(state.shift){ state.shift=false; insRaw('exp('); } else insRaw('ln('); }});

onPDAll('[data-trig]', el=>{
  clearForNewEntry();
  const base=el.dataset.trig; let raw='';
  if(state.shift && !state.hyp){ raw='a'+base+'('; }
  else if(state.shift && state.hyp){ raw='a'+base+'h('; }
  else if(state.hyp){ raw=base+'h('; }
  else{ raw=base+'('; }
  state.shift=false; insRaw(raw);
});

onPD(qs('#btn0'),  ()=>{ if(state.shift){ state.shift=false; insRaw('Rnd(');} else insRaw('0'); });
onPD(qs('#btnDot'),()=>{
  if(state.shift){
    state.shift=false;
    insRaw('RAN#');       // bez závorek
  } else {
    insRaw('.');
  }
});

onPD(qs('#btnEXP'),()=>{ if(state.shift){ state.shift=false; insRaw('π'); } else insRaw('E'); });
onPD(qs('#btnAns'),()=>{ if(state.shift){ state.shift=false; state.drg = state.drg==='DEG'?'RAD':state.drg==='RAD'?'GRAD':'DEG'; if(state.resultShown) updateResultView(); render(); } else insRaw('Ans'); });
onPD(qs('#btnEq'), ()=>{ 
  if(state.shift){ state.shift=false; insRaw('%'); return; }
  if(state.resultShown && !state.editAfterResult && state.repeat){
    const sym = prettyOp(state.repeat.op);
    state.raw = 'Ans' + sym + String(state.repeat.rhs);
    state.cursor = state.raw.length;
  }
  evaluate();
});

onPDAll('[data-act]', el=>{ const a=el.dataset.act; if(a==='del') back(); else if(a==='ac') ac(); });

function opAfterResult(sym){
  if(state.resultShown && !state.editAfterResult){
    // Necháme výsledek viditelný, jen začneme nový výraz "Ans <op>"
    state.editAfterResult = true;
    state.raw = 'Ans' + sym;
    state.cursor = state.raw.length;
    render();
  } else {
    insRaw(sym);
  }
}


onPDAll('[data-ins]', el=>{
  const t=el.dataset.ins;
  if(state.modeStage>0 && /^[0-9]$/.test(t)){ handleMenuChoice(t); return; }

  if(t==='+'||t==='−'||t==='×'||t==='÷'){ opAfterResult(t); }
  else if(t==='('||t===')'||t===','||/^[0-9.]$/.test(t)){ insRaw(t); }
  else { insRaw(t); }
});
function prettyOp(op){ return op==='+'?'+': op==='-'?'−': op==='*'?'×': op==='/'?'÷': op; }

function captureRepeat(tokens){
  const n = tokens.length;
  if(n<3 || tokens[n-1].type!=='num'){ state.repeat=null; return; }
  let i = n-2;
  while(i>=0 && !(tokens[i].type==='op' && ['+','-','*','/','^'].includes(tokens[i].op))) i--;
  if(i<0){ state.repeat=null; return; }
  state.repeat = { op: tokens[i].op, rhs: tokens[n-1].value };
}
/* ===== parser ===== */
function normalizeInput(s){
  s=s.replace(/\s+/g,'').replace(/×/g,'*').replace(/÷/g,'/').replace(/−/g,'-');
  s = s.replace(/RAN#(?!\s*\()/g, 'RAN#()'); // RAN# → RAN#() pokud nemá ( )
  s=autoCloseUnary(s);
  s=autoCloseRoot(s);

  const sep    = '[∟]'; // pouze náš symbol, žádné "L" apod.
  const mixRe  = new RegExp(`(^|[^0-9.])(-?\\d+)${sep}(\\d+)${sep}(\\d+)(?![0-9.])`, 'g');
  const fracRe = new RegExp(`(^|[^0-9.])(-?\\d+)${sep}(\\d+)(?![0-9.])`, 'g');

  let prev;
  do {
    prev = s;
    s = s.replace(mixRe,  (_m, pre, a, b, c) => `${pre}(${a}+(${b})/(${c}))`);
  } while (prev !== s);

  s = s.replace(fracRe, (_m, pre, n, d) => `${pre}((${n})/(${d}))`);
  s = s.replace(/\s+/g,'');

  s=s.replace(/sin\^\(-1\)\(/g,'asin(').replace(/cos\^\(-1\)\(/g,'acos(').replace(/tan\^\(-1\)\(/g,'atan(');
  s=s.replace(/Ans/g,String(state.ans)).replace(/π/g,String(Math.PI));
  // plné DMS: d ° m ′ s ″
s = s.replace(
  /(-?\d+(?:\.\d+)?)°\s*(\d+(?:\.\d+)?)′\s*(\d+(?:\.\d+)?)″/g,
  (_, d, m, sec) => String(dmsToDeg(parseFloat(d), parseFloat(m), parseFloat(sec)))
);
// jen stupně + minuty: doplň sekundy = 0
s = s.replace(
  /(-?\d+(?:\.\d+)?)°\s*(\d+(?:\.\d+)?)′/g,
  (_, d, m) => String(dmsToDeg(parseFloat(d), parseFloat(m), 0))
);
// jen stupně: doplň minuty = 0, sekundy = 0
// (není-li bezprostředně po ° další DMS symbol nebo číslo minut)
s = s.replace(
  /(-?\d+(?:\.\d+)?)°(?!\s*[\d′″])/g,
  (_, d) => String(dmsToDeg(parseFloat(d), 0, 0))
);

  s=s.replace(/(-?\d+(?:\.\d+)?)C(-?\d+(?:\.\d+)?)/g,'nCr($1,$2)');
  s=s.replace(/(-?\d+(?:\.\d+)?)P(-?\d+(?:\.\d+)?)/g,'nPr($1,$2)');
  return s;
}

function autoCloseUnary(s){
  const unary=['sin','cos','tan','asin','acos','atan','sinh','cosh','tanh','asinh','acosh','atanh',
               'sqrt','cbrt','log','ln','exp','pow10','abs','ceil','floor','inv','Rnd'];
  let out='', i=0;

  while(i<s.length){
    let name=null;
    for(const n of unary){ if(s.startsWith(n+'(', i)){ name=n; break; } }
    if(!name){ out+=s[i++]; continue; }

    const open = i + name.length;

    let depth=0, j=open;
    if(s[open]==='('){
      depth=1; j=open+1;
      while(j<s.length && depth>0){
        if(s[j]==='(') depth++;
        else if(s[j]===')') depth--;
        j++;
      }
      if(depth===0){ out += s.slice(i, j); i = j; continue; }
    }

    out += name+'(';
    i = open+1;
    let k=i;

    if(s[k]=='+'||s[k]=='-') k++;
    while(k<s.length && /[0-9.]/.test(s[k])) k++;
    while(k<s.length && (s[k]==='°'||s[k]==='′'||s[k]==='″')) k++;
    if((s[k]==='E'||s[k]==='e') && /[-+0-9]/.test(s[k+1])){
      k++; if(s[k]=='+'||s[k]=='-') k++;
      while(k<s.length && /[0-9]/.test(s[k])) k++;
    }

    if(k>=s.length){ out += s.slice(i,k)+')'; i=k; }
    else if(s[k]===')'){ out += s.slice(i,k+1); i=k+1; }
    else if('+-*/^,'.includes(s[k])){ out += s.slice(i,k)+')'+s[k]; i=k+1; }
    else { out += s[i]; i++; }
  }
  return out;
}

function autoCloseRoot(s){
  let out='', i=0;
  while(i<s.length){
    if(s.startsWith('root(', i)){
      const open = i + 4;
      let depth=1, j=open+1;
      while(j<s.length && depth>0){
        if(s[j]==='(') depth++;
        else if(s[j]===')') depth--;
        j++;
      }
      if(depth===0){ out += s.slice(i, j); i = j; continue; }

      out += 'root(';
      i = open+1;

      let a=i;
      if(s[a]=='+'||s[a]=='-') a++;
      while(a<s.length && /[0-9.]/.test(s[a])) a++;
      if((s[a]==='E'||s[a]==='e') && /[-+0-9]/.test(s[a+1])){
        a++; if(s[a]=='+'||s[a]=='-') a++; while(a<s.length && /[0-9]/.test(s[a])) a++;
      }
      if(s[a]!==','){ out+=s[i]; i++; continue; }
      out += s.slice(i, a+1);
      i = a+1;

      let b=i;
      if(s[b]=='+'||s[b]=='-') b++;
      while(b<s.length && /[0-9.]/.test(s[b])) b++;
      if((s[b]==='E'||s[b]==='e') && /[-+0-9]/.test(s[b+1])){
        b++; if(s[b]=='+'||s[b]=='-') b++; while(b<s.length && /[0-9]/.test(s[b])) b++;
      }

      if(b>=s.length){ out += s.slice(i,b) + ')'; i=b; }
      else if(s[b]===')'){ out += s.slice(i,b+1); i=b+1; }
      else if('+-*/^,'.includes(s[b])){ out += s.slice(i,b) + ')' + s[b]; i=b+1; }
      else { out += s[i]; i++; }
      continue;
    }
    out += s[i++];
  }
  return out;
}

function tokenize(s){
  const t=[];let i=0;const dig=c=>/[0-9]/.test(c), lettr=c=>/[A-Za-z#]/.test(c);
  while(i<s.length){
    const c=s[i];
    if(dig(c)||(c==='.'&&dig(s[i+1]))){
      let j=i+1, num=c;
      while(j<s.length&&/[0-9.]/.test(s[j])) num+=s[j++];
      if((s[j]==='E'||s[j]==='e')&&/[-+0-9]/.test(s[j+1])){
        num+=s[j++]; if(s[j]=='+'||s[j]=='-') num+=s[j++]; while(j<s.length&&/[0-9]/.test(s[j])) num+=s[j++];
      }
      t.push({type:'num',value:+num}); i=j; continue;
    }
    if(lettr(c)){ let j=i+1, id=c; while(j<s.length&&/[A-Za-z0-9_#]/.test(s[j])) id+=s[j++]; t.push({type:'id',value:id}); i=j; continue; }
    if(c==='('||c===')'||c===','){ t.push({type:c}); i++; continue; }
    if(c==='+'||c==='-'||c==='*'||c==='/'||c==='^'){ t.push({type:'op',op:c}); i++; continue; }
    if(c==='!'||c==='%'){ t.push({type:'post',op:c}); i++; continue; }
    throw Error('Neznámý znak: '+c);
  }
  return t;
}
function toRPN(tokens){
  const out=[], ops=[], argc=[];
  const prec={'unary-':5,'^':4,'*':3,'/':3,'mod':3,'+':2,'-':2,'!':6,'%':6};
  const right={'^':1};
  let prev='start';
  for(const t of tokens){
    if(t.type==='num'){ out.push(t); prev='num'; continue; }
    if(t.type==='id'){
      if(t.value==='mod'){
        while(ops.length){
          const top=ops[ops.length-1];
          if(top.type==='op'&&( (prec[top.op]>prec.mod) || (prec[top.op]===prec.mod && !right[top.op]) )) out.push(ops.pop());
          else break;
        }
        ops.push({type:'op',op:'mod'}); prev='op'; continue;
      }
      ops.push({type:'func',name:t.value}); prev='func'; continue;
    }
    if(t.type==='op'){
      if(t.op==='-'&&(prev==='start'||prev==='op'||prev==='('||prev==='comma')){
        const u={type:'op',op:'unary-'};
        while(ops.length&&ops[ops.length-1].type==='op'&&prec[ops[ops.length-1].op]>prec[u.op]) out.push(ops.pop());
        ops.push(u);
      }else{
        while(ops.length){
          const top=ops[ops.length-1];
          if(top.type==='op'&&(prec[top.op]>prec[t.op]||(prec[top.op]===prec[t.op]&&!right[top.op]))) out.push(ops.pop());
          else break;
        }
        ops.push({type:'op',op:t.op});
      }
      prev='op'; continue;
    }
    if(t.type==='post'){
      const p={type:'op',op:t.op==='!'?'!':'%post'};
      while(ops.length&&ops[ops.length-1].type==='op'&&prec[ops[ops.length-1].op]>prec['!']) out.push(ops.pop());
      ops.push(p); prev='post'; continue;
    }
    if(t.type==='('){ ops.push(t); argc.push(1); prev='('; continue; }
    if(t.type===','){ while(ops.length&&ops[ops.length-1].type!=='(') out.push(ops.pop()); if(argc.length) argc[argc.length-1]++; prev='comma'; continue; }
    if(t.type===')'){
      while(ops.length&&ops[ops.length-1].type!=='(') out.push(ops.pop());
      if(!ops.length) throw Error('Chybí "("');
      ops.pop(); const n=argc.pop()||1;
      if(ops.length&&ops[ops.length-1].type==='func'){ const f=ops.pop(); out.push({type:'func',name:f.name,argc:n}); }
      prev=')'; continue;
    }
  }
  while(ops.length){
    const x=ops.pop();
    if(x.type==='(') throw Error('Chybí ")"');
    if(x.type==='func') out.push({type:'func',name:x.name,argc:1}); else out.push(x);
  }
  return out;
}
function evalRPN(rpn){
  const st=[];
  const toRad=v=>state.drg==='DEG'?v*Math.PI/180:state.drg==='GRAD'?v*Math.PI/200:v;
  const fromRad=r=>state.drg==='DEG'?r*180/Math.PI:state.drg==='GRAD'?r*200/Math.PI:r;
const map={
  // goniometrie – výstup “zacvakneme” na 0/±1 kvůli plovoucí čárce
  sin:a=>cleanTrig(Math.sin(toRad(a))),
  cos:a=>cleanTrig(Math.cos(toRad(a))),
  tan:a=>cleanTrig(Math.tan(toRad(a))),

  // inverzní – vstup zacvaknout do [-1,1]; výsledek podle DRG
  asin:a=>fromRad(Math.asin(clampUnit(a))),
  acos:a=>fromRad(Math.acos(clampUnit(a))),
  atan:a=>fromRad(Math.atan(a)),

  // hyperbolické – volitelné zacvaknutí (tanh ~ ±1, sinh ~ 0)
  sinh:a=>cleanTrig(Math.sinh(a)),
  cosh:a=>cleanTrig(Math.cosh(a)),
  tanh:a=>cleanTrig(Math.tanh(a)),

  asinh:a=>Math.asinh(a), acosh:a=>Math.acosh(a), atanh:a=>Math.atanh(a),

  log:a=>Math.log10(a), ln:a=>Math.log(a), exp:a=>Math.exp(a),
  sqrt:a=>Math.sqrt(a), cbrt:a=>Math.cbrt(a), root:(y,x)=>x**(1/y),
  abs:a=>Math.abs(a), ceil:a=>Math.ceil(a), floor:a=>Math.floor(a), inv:a=>1/a,
  pow10:a=>10**a, pow:(a,b)=>a**b, nCr:(n,r)=>comb(n,r), nPr:(n,r)=>perm(n,r),
  gcd:(a,b)=>gcd(a,b), lcm:(a,b)=>lcm(a,b), mod:(a,b)=>mod(a,b),
  'RAN#':()=>Math.random(), Rnd:a=>roundSig(a,10),

  Pol:(x,y)=>({t:'pair',a:Math.hypot(x,y),b:fromRad(Math.atan2(y,x))}),
  Rec:(r,th)=>{const rad=toRad(th);return{t:'pair',a:r*Math.cos(rad),b:r*Math.sin(rad)};},

  DMS:a=>({t:'dms',v:a}),
  fact:a=>fact(a)
};

  for(const t of rpn){
    if(t.type==='num'){ st.push(t.value); continue; }
    if(t.type==='op'){
      if(t.op==='unary-'){ st.push(-st.pop()); continue; }
      if(t.op==='!'){ st.push(fact(st.pop())); continue; }
      if(t.op==='%post'){ st.push(st.pop()/100); continue; }
      const b=st.pop(), a=st.pop();
      st.push(t.op==='+'?a+b:t.op==='-'?a-b:t.op==='*'?a*b:t.op==='/'?a/b:t.op==='^'?a**b:mod(a,b));
      continue;
    }
    if(t.type==='func'){ const args=[]; for(let i=0;i<t.argc;i++) args.unshift(st.pop()); st.push(map[t.name](...args)); continue; }
  }
  if(st.length!==1) throw Error('Chybný výraz'); return st[0];
}

/* pomocné */
function fact(n){ n=Math.round(n); if(n<0) return NaN; if(n>170) return Infinity; let r=1; for(let i=2;i<=n;i++) r*=i; return r; }
function gcd(a,b){ a=Math.trunc(Math.abs(a)); b=Math.trunc(Math.abs(b)); if(a===0)return b; if(b===0)return a; while(b){ const t=b; b=a%b; a=t; } return a; }
function lcm(a,b){ a=Math.trunc(a); b=Math.trunc(b); return a&&b?Math.abs(a*b)/gcd(a,b):0; }
function mod(a,b){ if(b===0) return NaN; return a-b*Math.floor(a/b); }
function comb(n,r){ n=Math.round(n); r=Math.round(r); if(r<0||n<0||r>n) return NaN; r=Math.min(r,n-r); let num=1,den=1; for(let i=1;i<=r;i++){ num*=n-r+i; den*=i; } return num/den; }
function perm(n,r){ n=Math.round(n); r=Math.round(r); if(r<0||n<0||r>n) return NaN; let p=1; for(let i=0;i<r;i++) p*=(n-i); return p; }
function roundSig(x,n=12){ if(!isFinite(x)) return x; if(x===0) return 0; const d=Math.ceil(Math.log10(Math.abs(x))); const p=n-d; const m=10**p; return Math.round(x*m)/m; }
function stripZeros(s){ return s.replace(/(\.\d*?[1-9])0+$/,'$1').replace(/\.0+$/,'').replace(/^-0$/,'0'); }
function clampUnit(x, eps=1e-12){
  if (x > 1 && x < 1 + eps) return 1;
  if (x < -1 && x > -1 - eps) return -1;
  return x;
}
// zacvakni výstup trig funkcí na 0 / ±1, když je to “téměř” ono
function cleanTrig(x, eps=1e-12){
  if (!isFinite(x)) return x;
  if (Math.abs(x) < eps) return 0;
  if (Math.abs(x - 1) < eps) return 1;
  if (Math.abs(x + 1) < eps) return -1;
  return x;
}
  function toEngineering(x){
  if(!isFinite(x)) return String(x);
  if(x===0) return '0';
  const e=Math.floor(Math.log10(Math.abs(x)));
  const E=Math.floor(e/3)*3;
  const m=x/10**E;
  const mant = stripZeros(m.toPrecision(9));
  return `<span class="sci">${mant}<span class="times">×</span><span class="ten">10</span><sup class="exp">${E}</sup></span>`;
}
function toScientificAuto(x){
  if(!isFinite(x)) return String(x);
  if(x===0) return '0';
  let e = Math.floor(Math.log10(Math.abs(x)));
  let m = x / 10**e;
  let mant = stripZeros(m.toPrecision(9));
  if(Math.abs(+mant) >= 10){
    e += 1;
    m /= 10;
    mant = stripZeros(m.toPrecision(9));
  }
  return `<span class="sci">${mant}<span class="times">×</span><span class="ten">10</span><sup class="exp">${e}</sup></span>`;
}
function toFractionStr(x, mixed=true, maxDen=1e6){
  if(!isFinite(x)) return String(x);
  const sign = x<0 ? -1 : 1;
  let a = Math.abs(x);
  let w = Math.floor(a), f = a - w;
  if(f === 0) return (sign<0?'-':'') + String(w);
  let h1=1,h0=0,k1=0,k0=1,b=f;
  while(true){
    let A=Math.floor(b), h2=A*h1+h0, k2=A*k1+k0;
    if(k2>maxDen) break;
    h0=h1; k0=k1; h1=h2; k1=k2;
    const diff=Math.abs(f - h1/k1);
    if(diff<1e-12 || !isFinite(1/(b-A))) break;
    b = 1/(b-A);
  }
  let num=h1, den=k1;
  if(!mixed){ num = w*den + num; w = 0; }
  const body = (w ? (w + ' ∟ ' + num + ' ∟ ' + den) : (num + ' ∟ ' + den));
  return (sign<0?'-':'') + body;
}
function degToDMS(x){
  const sign = x < 0 ? -1 : 1;
  x = Math.abs(x);

  let d = Math.floor(x);
  let mf = (x - d) * 60;
  let m = Math.floor(mf);
  let s = (mf - m) * 60;

  // zaokrouhlení sekund + normalizace přenosu 60″ → +1′, 60′ → +1°
  s = Math.round(s * 1e6) / 1e6;         // přesnost na 1e-6 s
  if (s >= 60) { s -= 60; m += 1; }
  if (m >= 60) { m -= 60; d += 1; }

  const prefix = sign < 0 ? '-' : '';
  return prefix + d + '°' + m + '′' + stripZeros(String(s)) + '″';
}

function dmsToDeg(d,m,s){ const sign=d<0?-1:1; d=Math.abs(d); return sign*(d+m/60+s/3600); }

function formatNumWithOptions(v){
  if(!isFinite(v)) return String(v);
  const x = roundSig(v,12);

  if(state.dmsDisplay) return degToDMS(x);
  if(state.eng)        return toEngineering(x);
  if(state.frac)       return toFractionStr(x,state.fracMixed);

  const ax = Math.abs(x);
  // Malé/velké hodnoty: vždy hezká vědecká notace
  if(ax !== 0 && (ax >= 1e8 || ax < 1e-8)){
    return toScientificAuto(x);
  }

  // Jinak použijeme toPrecision – ale pokud by vrátilo e-zápis,
  // vynutíme naši vědeckou notaci s ×10^
  const s = stripZeros(x.toPrecision(12));
  if (/[eE]/.test(s)) {
    return toScientificAuto(x);
  }
  return s;
}

function updateResultView(){
  if(!state.lastRes){ state.resultStr=''; state.resultShown=false; render(); return; }
  if(state.lastRes.type==='num'){ state.resultStr = formatNumWithOptions(state.lastRes.v); }
  else if(state.lastRes.type==='pair'){ state.resultStr = `(${formatNumWithOptions(state.lastRes.a)}, ${formatNumWithOptions(state.lastRes.b)})`; }
  state.resultShown=true; render();
}
function evaluate(){
  try{
    const hadSep = /[∟]/.test(state.raw);
const hadDMS = /[°′″]/.test(state.raw);
const norm = normalizeInput(state.raw);

    const toks = tokenize(norm);
    const rpn  = toRPN(toks);
    let res    = evalRPN(rpn);

    if(res && res.t==='pair'){
      state.ans=NaN; state.lastRes={type:'pair',a:+res.a,b:+res.b}; state.repeat=null;
    }else if(res && res.t==='dms'){
      state.ans=+res.v; state.lastRes={type:'num',v:+res.v}; state.dmsDisplay=true; state.repeat=null;
    }else{
      state.ans=+res; state.lastRes={type:'num',v:+res}; captureRepeat(toks);
    }

    if(hadSep){ state.frac=true; state.fracMixed=true; }
else { state.frac=false; }

// Pokud uživatel psal DMS, ukaž výsledek rovnou ve stupních-minutách-vteřinách
if(hadDMS){ state.dmsDisplay = true; }

state.editAfterResult=false;
updateResultView();

  }catch(_){
    state.lastRes=null; state.resultStr='Error';
    state.resultShown=true; state.editAfterResult=false; state.repeat=null; render();
  }
}

/* init */
render();
fitToViewport();
updateExamUI();

/* klávesnice */
addEventListener('keydown',e=>{
  const k=e.key;
  if(k==='L'){ insRaw('∟'); return; }
  if(k==='Enter'){e.preventDefault();evaluate();return;}
  if(k==='Backspace'){e.preventDefault();back();return;}
  if(k==='Escape'){e.preventDefault();ac();return;}
  if(k==='ArrowLeft'){e.preventDefault();moveCursor(-1);return;}
  if(k==='ArrowRight'){e.preventDefault();moveCursor(+1);return;}
  if(/^[0-9]$/.test(k)){
    if(state.modeStage>0){ handleMenuChoice(k); }
    else { insRaw(k); }
    return;
  }

  if(k==='('||k===')'||k===','||k==='.'||k==='%'){insRaw(k);return;}
  if(k==='^'){opAfterResult('^');return;}
  if(k==='+'){opAfterResult('+');return;}
  if(k==='-'){opAfterResult('−');return;}
  if(k==='*'){opAfterResult('×');return;}
  if(k==='/'){opAfterResult('÷');return;}
  if(k==='e'){insRaw('E');return;}
});
</script>

<script>
  if ('serviceWorker' in navigator) {
    const SW_URL = './sw.js?v=2025-09-27b'; // zvyšuj verzi při deployi
    const FLAG = 'updateReady';

    const ui = {
      bar: null, btn: null,
      show() {
        if (!this.bar) {
          this.bar = document.createElement('div');
          this.bar.style.cssText = 'position:fixed;left:0;right:0;bottom:0;background:#111827;color:#fff;padding:10px 14px;display:flex;gap:10px;align-items:center;z-index:99999';
          this.bar.innerHTML = '<span>Je dostupná nová verze.</span>';
          this.btn = document.createElement('button');
          this.btn.textContent = 'Aktualizovat';
          this.btn.style.cssText = 'margin-left:auto;background:#10b981;border:none;color:#fff;padding:8px 12px;border-radius:8px;cursor:pointer';
          this.bar.appendChild(this.btn);
          document.body.appendChild(this.bar);
          this.btn.addEventListener('click', () => {
            // aktivuj novou verzi
            if (window.__swWaiting) {
              window.__swWaiting.postMessage({ type: 'SKIP_WAITING' });
            }
          });
        }
        this.bar.style.display = 'flex';
      },
      hide() { if (this.bar) this.bar.style.display = 'none'; }
    };

    function markReady(on) {
      try { localStorage.setItem(FLAG, on ? '1' : ''); } catch {}
    }
    function isMarked() {
      try { return localStorage.getItem(FLAG) === '1'; } catch { return false; }
    }

    window.addEventListener('load', async () => {
      try {
        const reg = await navigator.serviceWorker.register(SW_URL, { scope: './' });

        // Každé spuštění aktivně zkusí najít update
        reg.update().catch(()=>{});
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible') {
    navigator.serviceWorker.getRegistration()
      .then(reg => reg && reg.update().catch(()=>{}));
  }
});

        // Když se objeví nová verze:
        reg.addEventListener('updatefound', () => {
          const sw = reg.installing;
          if (!sw) return;
          sw.addEventListener('statechange', () => {
            if (sw.state === 'installed' && navigator.serviceWorker.controller) {
              // Nová verze je připravená (waiting)
              window.__swWaiting = reg.waiting || sw; // cache waiting
              markReady(true);
              ui.show();
            }
          });
        });

        // Pokud je čekající verze už teď (třeba po reloadu)
        if (reg.waiting) {
          window.__swWaiting = reg.waiting;
          markReady(true);
          ui.show();
        } else if (isMarked()) {
          // Bezpečnostní síť: když máme flag, ale waiting není → ještě jednou update()
          reg.update().catch(()=>{});
        }

        // Když se aktivuje nový controller (po SKIP_WAITING) → reload
        navigator.serviceWorker.addEventListener('controllerchange', () => {
          markReady(false);
          location.reload();
        });

        // Pokud při dalším spuštění už běží nová verze, flag smažeme (není co nabízet)
        if (!navigator.serviceWorker.controller) {
          // první instalace – žádná lišta
          markReady(false);
        }
      } catch (e) {
        console.warn('SW reg failed', e);
      }
    });
  }
</script>



<!-- QR overlay (statický náhled) -->
<div id="qrBackdrop" style="display:none;position:fixed;inset:0;background:rgba(0,0,0,.6);place-items:center;z-index:9999">
  <div style="background:#fff;border-radius:16px;padding:16px;color:#111;text-align:center">
    <img id="qrImg" src="./icons/qr.png?v=2" alt="QR kód" width="280" height="280">
    <div id="qrUrl" style="font:14px/1.2 ui-sans-serif,system-ui,Segoe UI,Roboto;margin-top:8px;word-break:break-all"></div>
  </div>
</div>
<script>
(() => {
  if (window.__qrInit) return; window.__qrInit = true;
  const qrBackdrop = document.getElementById('qrBackdrop');
  const btnQR = document.getElementById('btnQR');
  const qrUrl = document.getElementById('qrUrl');

  function isOpen(){ return qrBackdrop && qrBackdrop.style.display !== 'none'; }
  function openQR(){
    if (!qrBackdrop) return;
    qrBackdrop.style.display = 'grid';
    if(qrUrl) qrUrl.textContent = location.href;
    if (location.hash !== '#qr') history.pushState({ qr: true }, '', '#qr');
  }
  function closeQR(){
    if (!qrBackdrop) return;
    qrBackdrop.style.display = 'none';
    if (location.hash === '#qr') history.back();
  }

  btnQR && btnQR.addEventListener('pointerdown', openQR, { passive: true });
  qrBackdrop && qrBackdrop.addEventListener('pointerdown', (e) => { if (e.target === qrBackdrop) closeQR(); }, { passive: true });
  window.addEventListener('keydown', (e) => { if (e.key === 'Escape' && isOpen()) closeQR(); });
  window.addEventListener('popstate', () => { if (location.hash !== '#qr' && qrBackdrop) qrBackdrop.style.display = 'none'; });
  if (location.hash === '#qr') { history.replaceState(null, '', location.pathname + location.search); if (qrBackdrop) qrBackdrop.style.display = 'none'; }
})();
</script>

<script>
const QR = (() => {
  let overlay, video, note, btnX, running = false, stopCb = null;
  let pickBtn, fileInput, currentStream = null, raf = 0;
  let stopReader = null;

  // ➕ Nové:
  const isIOS = () => /iP(hone|ad|od)/.test(navigator.userAgent || '');
  let suspended = false;  // když otevřeme picker, pozastavíme sken
  let _resume = null;     // funkce, kterou naplní start() pro návrat ke skenu

  function releaseCamera(){
    try{
      if (currentStream) { currentStream.getTracks().forEach(t => t.stop()); }
    }catch(_){}
    currentStream = null;
    if (video) video.srcObject = null;
  }

  function buildUI(){
    if (overlay) return;

    overlay = document.createElement('div');
    overlay.style.cssText = "display:none;position:fixed;inset:0;background:rgba(0,0,0,.7);place-items:center;z-index:99999";

    const box = document.createElement('div');
    box.style.cssText = "background:#111;color:#fff;border-radius:16px;padding:12px;display:flex;flex-direction:column;gap:8px;align-items:center;max-width:92vw";

    video = document.createElement('video');
    video.playsInline = true;
    video.muted = true;
    video.style.cssText = "width:min(92vw,520px);max-height:70vh;border-radius:8px;background:#000";

    note = document.createElement('div');
    note.style.cssText = "font:600 16px/1.4 system-ui,Segoe UI,Roboto;opacity:.95;text-align:center";

    btnX = document.createElement('button');
    btnX.textContent = "Zavřít";
    btnX.style.cssText = "position:absolute;right:12px;top:12px;background:#ef4444;color:#fff;border:none;border-radius:10px;padding:8px 12px;font-weight:700;cursor:pointer";
    btnX.addEventListener('pointerdown', () => stop(), { passive:true });

 // „Nahrát fotku QR“ uprostřed dole
pickBtn = document.createElement('button');
pickBtn.textContent = 'Nahrát fotku QR';
pickBtn.style.cssText =
  "position:absolute;left:50%;bottom:12px;transform:translateX(-50%);" +
  "background:#3b82f6;border:none;color:#fff;padding:10px 14px;" +
  "border-radius:999px;font-weight:700;box-shadow:0 8px 20px rgba(0,0,0,.2)";

// průhledný input přes tlačítko – uživatelský tap jde přímo do inputu
fileInput = document.createElement('input');
fileInput.type = 'file';
fileInput.accept = 'image/*';
fileInput.multiple = false;
// ➕ důležité pro iOS „Pořídit snímek“ zadní kamerou:
fileInput.setAttribute('capture', 'environment');

// klíčové: NE display:none; musí být „viditelný“ (byť průhledný)
fileInput.style.cssText =
  "position:absolute;left:50%;bottom:12px;transform:translateX(-50%);" +
  "opacity:0;width:calc(100vw - 40px);max-width:320px;height:44px;" +
  "cursor:pointer;"; // pokryje tlačítko

// ➕ před otevřením pickeru POZASTAV skenování úplně (iOS je na to citlivý)
fileInput.addEventListener('pointerdown', () => {
  // pozastavený stav – po návratu z pickeru se vrátíme do skenu
  suspended = true;
  cancelAnimationFrame(raf);
  if (stopReader) { try { stopReader(); } catch {} }
  stopReader = null;
  releaseCamera();
}, { passive: true });

// po výběru souboru / pořízení fotky
fileInput.addEventListener('change', onPickFile);

// a přimontuj do overlaye
overlay.appendChild(pickBtn);
overlay.appendChild(fileInput);
box.appendChild(video);
box.appendChild(note);
overlay.appendChild(box);
overlay.appendChild(btnX);



    document.body.appendChild(overlay);
    overlay.addEventListener('pointerdown', (e) => {
  if (e.target === overlay) stop();
}, { passive:true });
window.addEventListener('keydown', (e) => {
  if (e.key === 'Escape' && overlay && overlay.style.display !== 'none') stop();
});
  }

  function parseExamPayload(text){
    try {
      const outer = JSON.parse(text);
      if (outer && outer.payload) return JSON.parse(outer.payload);
    } catch {}
    try {
      if (/^https?:\/\//i.test(text)) {
        const u = new URL(text);
        const p = u.searchParams.get('payload') || u.searchParams.get('p') || u.hash.replace(/^#/,'');
        if (p) return JSON.parse(decodeURIComponent(p));
        const code = u.searchParams.get('code');
        const type = (u.searchParams.get('type') || 'START').toUpperCase();
        const ts = +(u.searchParams.get('ts') || 0);
        const expSec = +(u.searchParams.get('expSec') || 0);
        if (code) return { code, type, ts, expSec };
      }
    } catch {}
    if (/^[A-Za-z0-9]{1,8}\|/.test(text)) {
      const [code, type='START', ts='0', expSec='0'] = text.split('|');
      return { code, type: String(type).toUpperCase(), ts:+ts, expSec:+expSec };
    }
    return null;
  }

  async function ensureFallback(){
    if ('BarcodeDetector' in window) return null;
    if (window.ZXing) return window.ZXing;
    try {
      await new Promise((res,rej)=>{ const s=document.createElement('script'); s.src="./vendor/zxing.min.js"; s.onload=res; s.onerror=rej; document.head.appendChild(s); });
      return window.ZXing;
    } catch {
      await new Promise((res,rej)=>{ const s=document.createElement('script'); s.src="https://cdn.jsdelivr.net/npm/@zxing/library@0.20.0/umd/index.min.js"; s.onload=res; s.onerror=rej; document.head.appendChild(s); });
      return window.ZXing;
    }
  }
async function restartLiveScan(noteText) {
  if (note && noteText) note.textContent = noteText;

  // Ukonči případného čteče a kameru
  cancelAnimationFrame(raf);
  if (stopReader) { try { stopReader(); } catch {} }
  stopReader = null;
  releaseCamera();

  // Znovu otevřít kameru
  let stream = null;
  try {
    stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:'environment' }, audio:false });
  } catch {
    if (note) note.textContent = 'Kameru nelze otevřít. Zkontrolujte oprávnění.';
    return;
  }
  currentStream = stream;
  video.srcObject = stream;
  try { await video.play(); } catch {}

  // Rovnou startni ZXing (na iOS spolehlivější)
  await startZXing();
}


  function deliver(text){
    const inner = parseExamPayload(text) || {};
    stop();
   if ((inner.type || 'START').toUpperCase() === 'START') Exam.start(inner.code);
  else Exam.finish();
  }
function rotateCanvas(srcCanvas, deg){
  const rad = (deg % 360) * Math.PI / 180;
  const s = Math.sin(rad), c = Math.cos(rad);
  const w = srcCanvas.width, h = srcCanvas.height;
  // nový rozměr obálky
  const nw = Math.abs(w * c) + Math.abs(h * s);
  const nh = Math.abs(w * s) + Math.abs(h * c);
  const dst = document.createElement('canvas');
  dst.width = Math.max(1, Math.round(nw));
  dst.height = Math.max(1, Math.round(nh));
  const ctx = dst.getContext('2d', { willReadFrequently: true });
  ctx.translate(dst.width / 2, dst.height / 2);
  ctx.rotate(rad);
  ctx.drawImage(srcCanvas, -w / 2, -h / 2);
  return dst;
}

async function onPickFile(){
  const f = fileInput.files && fileInput.files[0];
  fileInput.value = ''; // reset pro další výběr

  if (!f) {
    // Uživatel zrušil → rovnou obnovíme live scan, ať nemusí nic mačkat
    restartLiveScan('Namiřte na START QR…');
    return;
  }

  let text = null;
  try {
    await ensureFallback();
    if (window.ZXing && ZXing.BrowserMultiFormatReader) {
      const hints = new Map();
      hints.set(ZXing.DecodeHintType.POSSIBLE_FORMATS, [ZXing.BarcodeFormat.QR_CODE]);
      hints.set(ZXing.DecodeHintType.TRY_HARDER, true);

      const reader = new ZXing.BrowserMultiFormatReader(hints);

      const url = URL.createObjectURL(f);
      const img = document.createElement('img');
      img.src = url;
      await img.decode().catch(()=>{});
      const res = await reader.decodeFromImage(img).catch(()=>null);
      URL.revokeObjectURL(url);

      if (res) text = res.getText && res.getText();
    }
  } catch(_) {}

  if (text) {
    // Úspěch → deliver sám zavře overlay (volá stop())
    deliver(text);
    return;
  }

  // Neúspěch → nezavírej overlay. Okamžitě znova živý sken.
  restartLiveScan('QR z fotky se nepodařilo přečíst. Zkuste namířit kameru…');
}


async function start(kind){ // 'START' | 'END'
  if (running) return;
  buildUI();
  overlay.style.display = 'grid';
  note.textContent = (kind === 'START') ? 'Namiřte na START QR…' : 'Namiřte na END QR…';
  running = true;

  // kamera
  let stream = null;
  try {
    stream = await navigator.mediaDevices.getUserMedia({
      video: { facingMode: 'environment' },
      audio: false
    });
  } catch {
    note.textContent = 'Kameru nelze otevřít. Zkontrolujte oprávnění pro kameru.';
    running = false;
    return;
  }

  currentStream = stream;
  video.srcObject = stream;
  await video.play().catch(()=>{});

  // ✅ rovnou startni ZXing (žádný BarcodeDetector, žádné fallback smyčky)
  await startZXing();
}




  // 2) ZXing fallback (nebo primární, když BD není)
async function startZXing(){
  await ensureFallback();
  try {
    const hints = new Map();
    hints.set(ZXing.DecodeHintType.POSSIBLE_FORMATS, [ZXing.BarcodeFormat.QR_CODE]);
    hints.set(ZXing.DecodeHintType.TRY_HARDER, true);

    const reader = new ZXing.BrowserMultiFormatReader(hints);
    stopReader = () => { try { reader.reset(); } catch {} };

    reader.decodeFromVideoElementContinuously(video, (res /*, err*/) => {
      if (!running) return;
      if (res) {
        const text = res.getText && res.getText();
        if (text) {
          // pokud máš helper maybeDeliver, klidně volej ten:
          // maybeDeliver(text);
          deliver(text);
        }
      }
    });
  } catch {
    if (note) note.textContent = 'Čtečku se nepodařilo inicializovat.';
  }
}
 
function stop(){
  running = false;
  suspended = false;
  _resume = null;
  cancelAnimationFrame(raf);
  if (stopReader) { try { stopReader(); } catch {} }
  stopReader = null;
  releaseCamera();
  if (overlay) overlay.style.display = 'none';
}

  return { start, stop };
})();

function startExamScan(){ QR.start('START'); }
function endExamScan(){   QR.start('END'); }
</script>



</body>
</html>



































